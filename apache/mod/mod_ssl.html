<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Language" content="zh-CN" />
<meta name="keywords" content="Apache, 中文, 手册, 中文版, 中文手册, 中文版手册, 参考手册, 中文参考手册, 金步国" />
<meta name="description" content="Apache 2.2 中文版参考手册" />
<meta name="author" content="金步国" />
<link href="../style/css/manual-zip.css" rel="stylesheet" media="all" type="text/css" title="Main stylesheet" />
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" media="all" type="text/css" title="No Sidebar - Default font size" />
<link href="../style/css/manual-print.css" rel="stylesheet" media="print" type="text/css" />
<title>mod_ssl － Apache 2.2 中文版参考手册</title>
</head>
<body><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块索引</a> | <a href="../mod/directives.html">指令索引</a> | <a href="../faq/index.html">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">站点导航</a></p><p class="apache">Apache HTTP Server 版本2.2</p><img alt="" src="../images/feather.gif" /></div>
<div class="up"><a href="./index.html"><img title="&lt;-" alt="&lt;-" src="../images/left.gif" /></a></div>
<div id="path"><a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP Server</a> &gt; <a href="http://httpd.apache.org/docs/">文档</a> &gt; <a href="../index.html">版本2.2</a> &gt; <a href="./index.html">模块</a></div>

<div id="translation-info">　　 <a href="../translator_announcement.html#thanks">致谢</a> | 本篇译者：<a href="http://lamp.linux.gov.cn/jinbuguo_florilegium.html">金步国</a>(<a href="http://lamp.linux.gov.cn/jinbuguo_florilegium.html">其他作品</a>) | 本篇译稿完成时间：2008年8月3日[<a href="../translator_announcement.html#last_new" style="color:#F91C58">查看最新版本</a>] <a href="http://lamp.linux.gov.cn/Apache/ApacheMenu/index.html">电信镜像</a> <a href="http://lapp.unixmap.net/Apache/ApacheMenu/index.html">网通镜像</a></div>
<div id="page-content"><div id="preamble"><h1>Apache模块 mod_ssl</h1>

<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="module">
<tr><th><a href="module-dict.html#Description">说明</a></th><td>使用安全套接字层(SSL)和传输层安全(TLS)协议实现高强度加密传输</td></tr>
<tr><th><a href="module-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="module-dict.html#ModuleIdentifier">模块名</a></th><td>ssl_module</td></tr>
<tr><th><a href="module-dict.html#SourceFile">源文件</a></th><td>mod_ssl.c</td></tr>
</table>
<h3>概述</h3>

<p>这个模块提供了使用安全套接字层(SSL v2/v3)和传输层安全(TLS v1)协议实现高强度加密传输的功能。它由mod_ssl项目的作者Ralf S. Engeschall贡献，而mod_ssl最早是基于Ben Laurie的工作开发的。</p>

<p>这个模块依赖于<a href="http://www.openssl.org/">OpenSSL</a>提供的加密引擎和SSL引擎。</p>

<p>更多的细节、讨论、实例，请查看<a href="../ssl/index.html">SSL文档</a>。</p>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="envvars" id="envvars">环境变量</a></h2>

<p>这个模块通过环境变量提供了许多额外的SSL信息到SSI和CGI的名字空间(以供脚本使用)。下表列出了所有这些变量。出于兼容性考虑，许多变量都有别名，具体可以参考<a href="../ssl/ssl_compat.html">兼容性</a>一文。</p>

<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="bordered">
<tr><th><a name="table3">变量名</a></th><th>数据类型</th><th>描述</th></tr>
<tr><td><code>HTTPS</code></td><td>flag</td><td>是否正在使用HTTPS协议</td></tr>
<tr><td><code>SSL_PROTOCOL</code></td><td>string</td><td>SSL协议的版本(SSLv2, SSLv3, TLSv1)</td></tr>
<tr><td><code>SSL_SESSION_ID</code></td><td>string</td><td>十六进制表示的SSL会话ID</td></tr>
<tr><td><code>SSL_CIPHER</code></td><td>string</td><td>加密算法的名称</td></tr>
<tr><td><code>SSL_CIPHER_EXPORT</code></td><td>string</td><td>如果此算法是一个出口算法(export cipher)那么其值为<code>true</code></td></tr>
<tr><td><code>SSL_CIPHER_USEKEYSIZE</code></td><td>number</td><td>加密算法的位数(实际使用的)</td></tr>
<tr><td><code>SSL_CIPHER_ALGKEYSIZE</code></td><td>number</td><td>加密算法的位数(可能的)</td></tr>
<tr><td><code>SSL_COMPRESS_METHOD</code></td><td>string</td><td>经过协商后实际使用的SSL压缩方法</td></tr>
<tr><td><code>SSL_VERSION_INTERFACE</code></td><td>string</td><td>mod_ssl的版本</td></tr>
<tr><td><code>SSL_VERSION_LIBRARY</code></td><td>string</td><td>OpenSSL的版本</td></tr>
<tr><td><code>SSL_CLIENT_M_VERSION</code></td><td>string</td><td>客户端证书的版本</td></tr>
<tr><td><code>SSL_CLIENT_M_SERIAL</code></td><td>string</td><td>客户端证书的序列号</td></tr>
<tr><td><code>SSL_CLIENT_S_DN</code></td><td>string</td><td>客户端证书中特征名称(DN)域的值</td></tr>
<tr><td><code>SSL_CLIENT_S_DN_</code><em>x509</em></td><td>string</td><td>Component of client's Subject DN</td></tr>
<tr><td><code>SSL_CLIENT_I_DN</code></td><td>string</td><td>客户端证书发行者的特征名称(DN)域的值</td></tr>
<tr><td><code>SSL_CLIENT_I_DN_</code><em>x509</em></td><td>string</td><td>Component of client's Issuer DN</td></tr>
<tr><td><code>SSL_CLIENT_V_START</code></td><td>string</td><td>客户端证书有效期的开始时间</td></tr>
<tr><td><code>SSL_CLIENT_V_END</code></td><td>string</td><td>客户端证书有效期的结束时间</td></tr>
<tr><td><code>SSL_CLIENT_V_REMAIN</code></td><td>string</td><td>客户端证书还有多少天就将过期</td></tr>
<tr><td><code>SSL_CLIENT_A_SIG</code></td><td>string</td><td>客户端证书的签名算法</td></tr>
<tr><td><code>SSL_CLIENT_A_KEY</code></td><td>string</td><td>客户端证书的公钥算法</td></tr>
<tr><td><code>SSL_CLIENT_CERT</code></td><td>string</td><td>PEM编码的客户端证书</td></tr>
<tr><td><code>SSL_CLIENT_CERT_CHAIN_</code><em>n</em></td><td>string</td><td>在客户端证书链中PEM编码的证书</td></tr>
<tr><td><code>SSL_CLIENT_VERIFY</code></td><td>string</td><td>客户端认证的结果：<code>NONE</code>, <code>SUCCESS</code>, <code>GENEROUS</code>, <code>FAILED:</code><em>reason</em></td></tr>
<tr><td><code>SSL_SERVER_M_VERSION</code></td><td>string</td><td>服务器证书的版本</td></tr>
<tr><td><code>SSL_SERVER_M_SERIAL</code></td><td>string</td><td>服务器证书的序列号</td></tr>
<tr><td><code>SSL_SERVER_S_DN</code></td><td>string</td><td>服务器证书中特征名称(DN)域的值</td></tr>
<tr><td><code>SSL_SERVER_S_DN_</code><em>x509</em></td><td>string</td><td>Component of server's Subject DN</td></tr>
<tr><td><code>SSL_SERVER_I_DN</code></td><td>string</td><td>服务器证书发行者的特征名称(DN)域的值</td></tr>
<tr><td><code>SSL_SERVER_I_DN_</code><em>x509</em></td><td>string</td><td>Component of server's Issuer DN</td></tr>
<tr><td><code>SSL_SERVER_V_START</code></td><td>string</td><td>服务器证书有效期的开始时间</td></tr>
<tr><td><code>SSL_SERVER_V_END</code></td><td>string</td><td>服务器证书有效期的结束时间</td></tr>
<tr><td><code>SSL_SERVER_A_SIG</code></td><td>string</td><td>服务器证书的签名算法</td></tr>
<tr><td><code>SSL_SERVER_A_KEY</code></td><td>string</td><td>服务器证书的公钥算法</td></tr>
<tr><td><code>SSL_SERVER_CERT</code></td><td>string</td><td>PEM编码的服务器证书</td></tr>
</table>

<p><em>x509</em>要求X.509证书的特征名称(DN)域至少需要包含下列字段之一：<code>C,ST,L,O,OU,CN,T,I,G,S,D,UID,Email</code>。Apache2.1以后的版本<em>x509</em>还可以包含一个"<code>_n</code>"的数字后缀。如果被查询的DN具有多个同名属性，那么这个数字后缀就可以用来选择究竟是哪个属性。例如，服务器证书的DN域含有两个同名的"OU"字段，那么就可以用<code>SSL_SERVER_S_DN_OU_0</code>和<code>SSL_SERVER_S_DN_OU_1</code>来区分它们。</p>

<p><code>SSL_CLIENT_V_REMAIN</code>仅在2.1和更高版本中可见。</p>

</div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="logformats" id="logformats">自定义日志格式</a></h2>

<p>当<code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code>被静态编译进Apache或被作为DSO动态加载后，<code class="module"><a href="mod_log_config.html">mod_log_config</a></code>就可以使用一些额外的<a href="mod_log_config.html#formats">自定义日志格式</a>功能了。首先，有一个额外的"<code>%{</code><em>varname</em><code>}x</code>"日志格式，其中的"varname"可以是任意模块提供的任意变量名称。特别地，上表中列出了mod_ssl提供的变量。</p>
<p>出于兼容性考虑，还可以使用"<code>%{</code><em>name</em><code>}c</code>"语法，更多信息可以查看<a href="../ssl/ssl_compat.html">兼容性</a>一文。</p>
<div class="example"><h3>示例</h3><p><code>CustomLog logs/ssl_request_log "%t %h %{SSL_PROTOCOL}x %{SSL_CIPHER}x \"%r\" %b"</code></p></div>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLCACertificateFile" id="SSLCACertificateFile">SSLCACertificateFile</a> <a name="sslcacertificatefile" id="sslcacertificatefile">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于客户端认证的多合一CA证书(PEM格式)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLCACertificateFile <em>file-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令用于客户端认证。这个指令指定了一个<em>多合一</em>的CA证书，只有持有这些CA所签发证书的<em>客户端</em>才允许访问。这个所谓"多合一"证书文件其实就是将多个PEM格式的证书按照优先级顺序放置在同一个文件中而已。这个指令也可以由<code class="directive"><a href="#sslcacertificatepath">SSLCACertificatePath</a></code>指令代替，或者两个一起使用。</p>
<div class="example"><h3>示例</h3><p><code>SSLCACertificateFile /usr/local/apache2/conf/ssl.crt/ca-bundle-client.crt</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLCACertificatePath" id="SSLCACertificatePath">SSLCACertificatePath</a> <a name="sslcacertificatepath" id="sslcacertificatepath">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于客户端认证的CA证书(PEM格式)目录</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLCACertificatePath <em>directory-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令用于客户端认证。这个指令指定了一个包含CA证书的目录，只有持有这些CA所签发证书的<em>客户端</em>才允许访问。</p>
<p>该目录中的证书必须是PEM格式，并且它们都通过散列后的文件名访问。所以你不能只是把证书放到这个目录中就完事了：你还需要创建一个名为<em>hash-value</em><code>.N</code>的符号连接，并保证这个目录下的所有符号链接都准确无误。请使用mod_ssl附带的<code>Makefile</code>完成这项工作。</p>
<div class="example"><h3>示例</h3><p><code>SSLCACertificatePath /usr/local/apache2/conf/ssl.crt/</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLCADNRequestFile" id="SSLCADNRequestFile">SSLCADNRequestFile</a> <a name="sslcadnrequestfile" id="sslcadnrequestfile">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于定义"可接受的CA名称"列表的多合一CA证书(PEM格式)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLCADNRequestFile <em>file-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>在SSL握手阶段，当mod_ssl向客户端索取证书时，它会向客户端发送一个<em>可接受的CA名称</em>列表。客户端可以根据这些CA名称从它所持有的所有证书中选择一个最恰当的证书。</p>

<p>如果<code class="directive"><a href="#sslcadnrequestpath">SSLCADNRequestPath</a></code>和<code class="directive"><a href="#sslcadnrequestfile">SSLCADNRequestFile</a></code>都没有给出，那么向客户端发送的所有"可接受的CA名称"就由<code class="directive"><a href="#sslcacertificatefile">SSLCACertificateFile</a></code>和<code class="directive"><a href="#sslcacertificatepath">SSLCACertificatePath</a></code>决定，也就是所有可接受的CA名称正好就是所有用于客户端认证的CA证书中包含的名称。</p>

<p>在某些场合下，确实需要让"可接受的CA名称"与用于客户端认证的CA证书不一致。比如，客户端证书可能是由中间CA(非顶级CA)所签发。此时，就可以使用<code class="directive"><a href="#sslcadnrequestpath">SSLCADNRequestPath</a></code>和/或<code class="directive"><a href="#sslcadnrequestfile">SSLCADNRequestFile</a></code>指令来指定"可接受的CA名称"究竟是哪些。</p>

<p><code class="directive"><a href="#sslcadnrequestfile">SSLCADNRequestFile</a></code>必须指定一个<em>多合一</em>的CA证书，也就是将多个PEM格式的证书放置在同一个文件中。</p>

<div class="example"><h3>示例</h3><p><code>SSLCADNRequestFile /usr/local/apache2/conf/ca-names.crt</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLCADNRequestPath" id="SSLCADNRequestPath">SSLCADNRequestPath</a> <a name="sslcadnrequestpath" id="sslcadnrequestpath">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于定义"可接受的CA名称"列表的CA证书(PEM格式)目录</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLCADNRequestPath <em>directory-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>

<p>这个指令用于定义包含"<em>可接受的CA名称</em>"列表的CA证书(PEM格式)目录。更多细节请查看<code class="directive"><a href="#sslcadnrequestfile">SSLCADNRequestFile</a></code>指令。</p>

<p>该目录中的证书必须是PEM格式，并且它们都通过散列后的文件名访问。所以你不能只是把证书放到这个目录中就完事了：你还需要创建一个名为<em>hash-value</em><code>.N</code>的符号连接，并保证这个目录下的所有符号链接都准确无误。请使用mod_ssl附带的<code>Makefile</code>完成这项工作。</p>
<div class="example"><h3>示例</h3><p><code>SSLCADNRequestPath /usr/local/apache2/conf/ca-names.crt/</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLCARevocationFile" id="SSLCARevocationFile">SSLCARevocationFile</a> <a name="sslcarevocationfile" id="sslcarevocationfile">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于客户端认证的多合一CA证书撤销列表(PEM格式)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLCARevocationFile <em>file-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令用于客户端认证。这个指令指定了一个<em>多合一</em>的CA证书撤销列表(CRL,Certificate Revocation Lists)，CRL中的证书都被视为无效证书。这个所谓"多合一"的CRL文件其实就是将多个PEM格式的CRL按照优先级顺序放置在同一个文件中而已。这个指令也可以由<code class="directive"><a href="#sslcarevocationpath">SSLCARevocationPath</a></code>指令代替，或者两个一起使用。</p>
<div class="example"><h3>示例</h3><p><code>SSLCARevocationFile /usr/local/apache2/conf/ssl.crl/ca-bundle-client.crl</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLCARevocationPath" id="SSLCARevocationPath">SSLCARevocationPath</a> <a name="sslcarevocationpath" id="sslcarevocationpath">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于客户端认证的CA证书撤销列表(PEM格式)目录</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLCARevocationPath <em>directory-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令用于客户端认证。这个指令指定了一个包含多个CA证书撤销列表(CRL)的目录，CRL中的证书都被视为无效证书。</p>
<p>该目录中的CRL必须是PEM格式，并且它们都通过散列后的文件名访问。所以你不能只是把CRL文件放到这个目录中就完事了：你还需要创建一个名为<em>hash-value</em><code>.rN</code>的符号连接，并保证这个目录下的所有符号链接都准确无误。请使用mod_ssl附带的<code>Makefile</code>完成这项工作。</p>
<div class="example"><h3>示例</h3><p><code>SSLCARevocationPath /usr/local/apache2/conf/ssl.crl/</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLCertificateChainFile" id="SSLCertificateChainFile">SSLCertificateChainFile</a> <a name="sslcertificatechainfile" id="sslcertificatechainfile">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>服务器的CA证书链(PEM格式)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLCertificateChainFile <em>file-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令指定了一个<em>多合一</em>的CA证书：由直接签发服务器证书的CA证书开始，按证书链顺序回溯，一直到根CA的证书结束，这一系列的CA证书(PEM格式)就构成了服务器的证书链。</p>
<p>这个指令也可以由<code class="directive"><a href="#sslcacertificatepath">SSLCACertificatePath</a></code>指令代替，或者两个一起使用，用于明确的创建服务器的证书链。这个证书链将被与服务器证书一起发送给客户端。这有利于避免在执行客户端认证时多个CA证书之间出现混淆或冲突。因为虽然将服务器证书链上的某个CA证书放到<code class="directive"><a href="#sslcacertificatepath">SSLCACertificatePath</a></code>目录中对于证书链结构没什么影响，但是由这个CA签发的客户端证书也会在执行客户端认证的时候同时被认可，这通常不是你期望的结果。</p>
<p>小心：仅在服务器证书使用<em>单一</em>算法(RSA<em>或</em>DSA)的情况下，提供证书链才可行。如果你使用了RSA+DSA证书，那么仅在两个证书实际使用了<em>同一个</em>证书链的情况下才可行，否则客户端浏览器将被搞晕。</p>
<div class="example"><h3>示例</h3><p><code>SSLCertificateChainFile /usr/local/apache2/conf/ssl.crt/ca.crt</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLCertificateFile" id="SSLCertificateFile">SSLCertificateFile</a> <a name="sslcertificatefile" id="sslcertificatefile">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>服务器证书文件(PEM编码的X.509证书)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLCertificateFile <em>file-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令用于指定服务器持有的X.509证书(PEM编码)，其中还可以包含对应的RSA或DSA私钥。如果其中包含的私钥已经使用密语加密，那么在Apache启动的时候将会提示输入密语。如果服务器同时使用了RSA和DSA两种证书，那么该指令可以使用两次来分别指定两种证书的位置。</p>
<div class="example"><h3>示例</h3><p><code>SSLCertificateFile /usr/local/apache2/conf/ssl.crt/server.crt</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLCertificateKeyFile" id="SSLCertificateKeyFile">SSLCertificateKeyFile</a> <a name="sslcertificatekeyfile" id="sslcertificatekeyfile">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>服务器私钥文件(PEM编码)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLCertificateKeyFile <em>file-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令指定了服务器私钥文件(PEM编码)的位置。如果<code class="directive">SSLCertificateFile</code>指定的服务器证书文件中不包含相应的私钥，那么就必须使用该指令，否则就不需要使用。我们反对在服务器证书中包含私钥，正确的做法应该是将证书和私钥分开在不同的文件中。如果私钥文件已经使用密语加密，那么在Apache启动的时候将会提示输入密语。如果服务器同时使用了RSA和DSA两种证书，那么该指令可以使用两次来分别指定两种私钥的位置。</p>
<div class="example"><h3>示例</h3><p><code>SSLCertificateKeyFile /usr/local/apache2/conf/ssl.key/server.key</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLCipherSuite" id="SSLCipherSuite">SSLCipherSuite</a> <a name="sslciphersuite" id="sslciphersuite">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>允许客户端使用哪些加密算法套件</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLCipherSuite <em>cipher-spec</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLCipherSuite ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令的值是一个冒号分隔的OpenSSL<em>加密算法套件</em>字符串，用于在SSL握手过程中进行加密算法协商时告诉客户端允许使用哪些加密算法。该指令既可以用于主机级别的配置(在SSL握手阶段就按照允许算法进行协商)，也可以用于目录级别的配置(在收到HTTP请求后、发送HTTP应答前，强制使用新的允许算法进行SSL重协商)。</p>
<p>OpenSSL"<em>加密算法套件</em>"实际上是由4个属性组成：</p>
<ul>
<li><em>密钥交换算法</em>：<br />RSA或Diffie-Hellman算法的各种变种</li>
<li><em>认证算法</em>：<br />RSA, Diffie-Hellman, DSS 或 none</li>
<li><em>加密算法</em>：<br />AES, DES, Triple-DES, RC4, RC2, IDEA 或 none</li>
<li><em>摘要算法</em>：<br />MD5, SHA 或 SHA1</li>
</ul>
<p>可以指定加密算法套件中每个属性的算法，也可以使用别名指定一组特定的算法套件(<a href="#table1">表-1</a>)。</p>

<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="bordered">
<tr><th><a name="table1">标记</a></th><th>描述</th></tr>
<tr><td colspan="2"><em>密钥交换算法</em></td></tr>
<tr><td><code>kRSA</code></td><td>纯RSA密钥交换</td></tr>
<tr><td><code>kDHr</code></td><td>使用RSA密钥的Diffie-Hellman密钥交换</td></tr>
<tr><td><code>kDHd</code></td><td>使用DSA密钥的Diffie-Hellman密钥交换</td></tr>
<tr><td><code>kEDH</code></td><td>Ephemeral (temp.key) Diffie-Hellman key exchange (no cert)</td></tr>
<tr><td colspan="2"><em>认证算法</em></td></tr>
<tr><td><code>aNULL</code></td><td>不进行认证</td></tr>
<tr><td><code>aRSA</code></td><td>RSA认证</td></tr>
<tr><td><code>aDSS</code></td><td>DSS认证</td></tr>
<tr><td><code>aDH</code></td><td>Diffie-Hellman认证</td></tr>
<tr><td colspan="2"><em>加密算法</em></td></tr>
<tr><td><code>eNULL</code></td><td>不加密</td></tr>
<tr><td><code>AES</code></td><td>AES加密</td></tr>
<tr><td><code>DES</code></td><td>DES加密</td></tr>
<tr><td><code>3DES</code></td><td>Triple-DES加密</td></tr>
<tr><td><code>RC4</code></td><td>RC4加密</td></tr>
<tr><td><code>RC2</code></td><td>RC2加密</td></tr>
<tr><td><code>IDEA</code></td><td>IDEA加密</td></tr>
<tr><td colspan="2"><em>摘要算法</em></td></tr>
<tr><td><code>MD5</code></td><td>MD5摘要</td></tr>
<tr><td><code>SHA1</code></td><td>SHA1摘要</td></tr>
<tr><td><code>SHA</code></td><td>SHA摘要</td></tr>
<tr><td colspan="2"><em>别名</em></td></tr>
<tr><td><code>SSLv2</code></td><td>所有SSLv2算法</td></tr>
<tr><td><code>SSLv3</code></td><td>所有SSLv3算法</td></tr>
<tr><td><code>TLSv1</code></td><td>所有TLSv1算法</td></tr>
<tr><td><code>EXP</code></td><td>所有出口算法</td></tr>
<tr><td><code>EXPORT40</code></td><td>所有40-bit出口算法</td></tr>
<tr><td><code>EXPORT56</code></td><td>所有56-bit出口算法</td></tr>
<tr><td><code>LOW</code></td><td>所有低强度算法(非出口算法,DES)</td></tr>
<tr><td><code>MEDIUM</code></td><td>所有128-bit加密算法</td></tr>
<tr><td><code>HIGH</code></td><td>所有使用Triple-DES或更高强度的算法</td></tr>
<tr><td><code>RSA</code></td><td>所有使用RSA密钥交换的算法</td></tr>
<tr><td><code>DH</code></td><td>所有使用Diffie-Hellman密钥交换的算法</td></tr>
<tr><td><code>EDH</code></td><td>所有使用临时Diffie-Hellman密钥交换的算法</td></tr>
<tr><td><code>ADH</code></td><td>所有使用匿名Diffie-Hellman密钥交换的算法</td></tr>
<tr><td><code>DSS</code></td><td>所有使用DSS认证的算法</td></tr>
<tr><td><code>NULL</code></td><td>所有不加密的算法</td></tr>
</table>
<p>可以使用下面的语法增删算法以及确定在握手阶段协商的"算法套件"优先级顺序：</p>
<ul>
<li>[没有标记]: 向列表中增加一个算法套件</li>
<li><code>+</code>: 在列表中的相应的位置增加一个算法套件</li>
<li><code>-</code>: 从列表中临时删除相应的算法套件(之后还可以被再次添加)</li>
<li><code>!</code>: 从列表中永久删除相应的算法套件(之后<strong>不可以</strong>被再次添加)</li>
</ul>
<p>该指令默认值"<code>ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP</code>"的含义是：首先永久删除所有使用匿名Diffie-Hellman密钥交换的算法，然后添加使用RC4和RSA的算法，再然后顺序添加高中低强度的算法，最后再追加所有的SSLv2算法和出口算法(export ciphers)到列表结尾。</p>
<p>可以使用"<code>openssl ciphers -v</code>"命令查看所有可用的"<em>加密算法套件</em>"。</p>
<div class="example"><h3>示例</h3><p><code>SSLCipherSuite RSA:!EXP:!NULL:+HIGH:+MEDIUM:-LOW</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLCryptoDevice" id="SSLCryptoDevice">SSLCryptoDevice</a> <a name="sslcryptodevice" id="sslcryptodevice">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>指定硬件加密加速设备</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLCryptoDevice <em>engine</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLCryptoDevice builtin</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在使用"<code>-DSSL_ENGINE_EXPERIMENTAL</code>"编译mod_ssl的情况下才有效</td></tr>
</table>
<p>这个指令用于启用硬件加密加速设备，这种板载硬件设备可以加速SSL协议的处理速度，降低CPU负载。该指令仅在OpenSSL启用了"engine"支持的时候有效。OpenSSL 0.9.7以及以后的版本默认就已经启用了"engine"支持，而对于0.9.6版本则需要使用带有"-engine"后缀的版本才行。</p>

<p>请使用"<code>openssl engine</code>"命令检查可以使用哪些引擎名称。</p>

<div class="example"><h3>示例</h3><p><code>
# 这是一个Broadcom加速器：<br />
SSLCryptoDevice ubsec
</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLEngine" id="SSLEngine">SSLEngine</a> <a name="sslengine" id="sslengine">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>SSL引擎开关</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLEngine on|off|optional</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLEngine off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令用于开启或关闭SSL/TLS协议引擎。一般用于<code class="directive"><a href="../mod/core.html#virtualhost">&lt;VirtualHost&gt;</a></code>段中针对特定的虚拟主机开启SSL/TLS引擎。无论对于主服务器还是虚拟主机，SSL/TLS协议引擎都是默认关闭的。</p>
<div class="example"><h3>示例</h3><p><code>
&lt;VirtualHost _default_:443&gt;<br />
SSLEngine on<br />
...<br />
&lt;/VirtualHost&gt;
</code></p></div>
<p>对于Apache 2.1和更高版本，<code class="directive">SSLEngine</code>可以被设为<code>optional</code>以支持<a href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817</a>规范(在HTTP/1.1中升级到TLS)。目前尚无浏览器支持这个规范。[译者注]rfc2817描述如何使用HTTP/1.1的升级机制在一个现存的TCP连接上发起安全传输层(TLS)，这样就允许安全的和不安全的HTTP通信共享同一个"知名端口"。这种做法也支持“虚拟主机”，因此一个HTTP+TLS服务器能区分发往在同一个IP地址上的几个主机的消息。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLHonorCipherOrder" id="SSLHonorCipherOrder">SSLHonorCipherOrder</a> <a name="sslhonorcipherorder" id="sslhonorcipherorder">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>是否强制使用服务器端的加密算法套件优先级顺序</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLHonorCiperOrder on|off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLHonorCiperOrder off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在Apache 2.1及更高版本中有效，并且要求使用OpenSSL 0.9.7或更高版本</td></tr>
</table>
<p>在SSLv3/TLSv1握手阶段，服务器通常优先尊重客户端给出的加密算法套件优先级顺序。但是，如果将此指令设为"<code>on</code>"，那么将优先使用服务器端的优先级顺序。</p>
<div class="example"><h3>示例</h3><p><code>SSLHonorCipherOrder on</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLMutex" id="SSLMutex">SSLMutex</a> <a name="sslmutex" id="sslmutex">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>SSL引擎实现内部互斥操作的信号量(semaphore)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLMutex <em>type</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLMutex none</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令指定了SSL引擎使用什么样的信号量(互斥锁)来在多个Apache服务器进程之间实现串行化互斥操作。这个指令只能用于服务器全局配置，并且设计成和<code class="directive"><a href="../mod/mpm_common.html#acceptmutex">AcceptMutex</a></code>指令很接近。</p>
<p>目前可以使用下面这几种互斥<em>类型</em>：</p>
<ul>
<li><code>none | no</code>
    <p>这是默认值，也就是根本不使用任何互斥机制。如果使用这个设置的话，那么后果自负。因为目前互斥机制主要用于SSL会话缓存写入同步，所以没有互斥机制将会导致SSL会话缓存错误。所以我们反对使用默认值，而是推荐你明确指定一个互斥方法。</p></li>
<li><code>posixsem</code>
    <p>使用POSIX信号量，这是最优雅的互斥机制。如果底层平台和<a class="glossarylink" href="../glossary.html#apr" title="see glossary">APR</a>都支持，那么这是首选方法。</p></li>
<li><code>sysvsem</code>
    <p>使用SystemV IPC信号量，这是次优雅的互斥机制。如果在移除信号量之前进程崩溃，那么将会导致SysV信号量被"泄漏"。仅在底层平台和<a class="glossarylink" href="../glossary.html#apr" title="see glossary">APR</a>都支持的情况下才可以使用。</p></li>
<li><code>sem</code>
    <p>自动在<code>posixsem</code>与<code>sysvsem</code>之间选择一个"最佳"的方式：优先选择前者，仅在前者不可用时才选择后者。仅在底层平台和<a class="glossarylink" href="../glossary.html#apr" title="see glossary">APR</a>至少支持其中一种的情况下才可以使用。</p></li>
<li><code>pthread</code>
    <p>使用Posix线程互斥。仅在底层平台和<a class="glossarylink" href="../glossary.html#apr" title="see glossary">APR</a>都支持的情况下才可以使用。</p></li>
<li><code>fcntl:/path/to/mutex</code>
    <p>配合<code>fcntl()</code>函数使用一个物理的锁文件实现互斥。这是一个可移植的互斥机制(Win32平台除外)。请务必为<code>/path/to/mutex</code>使用一个本地文件，而不要使用一个位于NFS或AFS上的文件。仅在底层平台和<a class="glossarylink" href="../glossary.html#apr" title="see glossary">APR</a>都支持的情况下才可以使用。因为Apache父进程的PID将会被自动添加到<code>/path/to/mutex</code>中以确保唯一性，所以你不必担心会发生冲突。</p></li>
<li><code>flock:/path/to/mutex</code>
    <p>这个机制与<code>fcntl:/path/to/mutex</code>类似，只是使用了<code>flock()</code>函数。仅在底层平台和<a class="glossarylink" href="../glossary.html#apr" title="see glossary">APR</a>都支持的情况下才可以使用。</p></li>
<li><code>file:/path/to/mutex</code>
    <p>自动在<code>fcntl</code>和<code>flock</code>之间选择一个"最佳"的方式：优先选择前者，仅在前者不可用时才选择后者。仅在底层平台和<a class="glossarylink" href="../glossary.html#apr" title="see glossary">APR</a>至少支持其中一种的情况下才可以使用。</p></li>
<li><code>default | yes</code>
    <p>完全由底层平台和<a class="glossarylink" href="../glossary.html#apr" title="see glossary">APR</a>自主选择一个缺省的互斥机制。</p></li>
</ul>
<div class="example"><h3>示例</h3><p><code>SSLMutex file:/usr/local/apache/logs/ssl_mutex</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLOptions" id="SSLOptions">SSLOptions</a> <a name="ssloptions" id="ssloptions">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>配置SSL引擎的运行时选项</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLOptions [+|-]<em>option</em> ...</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>Options</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令用于配置SSL引擎的运行时选项。如果有多个<code>SSLOptions</code>可以作用于某个目录，那么将完全使用最特殊的那一个，而不存在继承或合并的问题。但是如果<code>SSLOptions</code>中的<em>所有</em>选项前都有"<code>+</code>"或"<code>-</code>"标记，那么这个指令将会被合并：以"<code>+</code>"开头的选项将会被添加到当前选项中，以"<code>-</code>"开头的选项将会被从当前选项中移除。</p>
<p>所有可用<em>选项</em>如下：</p>
<ul>
<li><code>StdEnvVars</code>
    <p>如果开启此选项，那么与SSL相关的CGI/SSI标准环境变量将会被创建。出于性能考虑，这个选项默认关闭，因为提取这些变量值的过程是非常消耗资源的。一般仅为CGI/SSI脚本开启。</p>
</li>
<li><code>CompatEnvVars</code>
    <p>如果开启此选项，那么为了兼容其他SSL解决方案而添加的额外CGI/SSI环境变量将会被创建。请参考<a href="../ssl/ssl_compat.html">兼容性</a>一节获取究竟将创建哪些变量的细节。</p>
</li>
<li><code>ExportCertData</code>
    <p>如果开启此选项，额外的CGI/SSI环境变量：<code>SSL_SERVER_CERT</code>, <code>SSL_CLIENT_CERT</code>, <code>SSL_CLIENT_CERT_CHAIN_</code><em>n</em>(<em>n</em>=0,1,2,..)将被创建。这些变量包含了作用于当前HTTPS连接的PEM编码的服务器/客户端X.509证书的相关信息，以及客户端证书链中所有证书的相关信息，它们可以被CGI脚本用来进行更深层次的证书检查。</p>
</li>
<li><code>FakeBasicAuth</code>
    <p>如果开启此选项，那么客户端X509证书中的特征名称(DN)字段的"Subject"值(可以使用"<code>openssl x509 -noout -subject -in <em>certificate</em>.crt</code>"命令查看)将被转化为HTTP基本认证的用户名。这就意味着可以将标准Apache认证方法用于访问控制，同时需要主意的是因为并没有从用户获取密码，所以每个用户名对应的密码都是"<code>xxj31ZMTZzkVA</code>"，也即是"<code>password</code>"经过3DES加密后的结果。对于那些基于MD5加密的系统(BSD系统)，则需要使用"<code>$1$OXLyS...$Owx8s2/m9/gfkcRVXzgoE/</code>"作为密码。</p>
</li>
<li><code>StrictRequire</code>
    <p>如果开启此选项，那么当<code>SSLRequireSSL</code>或<code>SSLRequire</code>要求禁止访问时，将<em>强制</em>禁止访问。默认情况下，当设置了"<code>Satisfy any</code>"时，如果通过了<code>SSLRequireSSL</code>或<code>SSLRequire</code>之外的其他访问控制检查，那么访问将被允许，这符合<code>Satisfy</code>指令的原意。但是在"<code>SSLOptions +StrictRequire</code>"的情况下，你可以使用<code>SSLRequireSSL</code>和/或<code>SSLRequire</code>在SSL连接上强制达到"<code>Satisfy All</code>"的效果。</p>
</li>
<li><code>OptRenegotiate</code>
    <p>默认情况下，当某个特定目录的SSL配置发生变化时，将会执行一个<em>完整的</em>SSL重新握手和协商过程。如果开启此选项，那么将允许优化SSL连接的重新协商操作，也就是省略不必要的握手过程，而只是进行细粒度的参数检查(仍然是安全的)。不过，在某些时候，只进行参数检查往往不是用户期望的结果，所以如果你想启用这个选项，请只对某些特定的目录启用。</p>
</li>
</ul>
<div class="example"><h3>示例</h3><p><code>
SSLOptions +FakeBasicAuth -StrictRequire<br />
&lt;Files ~ "\.(cgi|shtml)$"&gt;<br />
  SSLOptions +StdEnvVars +CompatEnvVars -ExportCertData<br />
&lt;Files&gt;</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLPassPhraseDialog" id="SSLPassPhraseDialog">SSLPassPhraseDialog</a> <a name="sslpassphrasedialog" id="sslpassphrasedialog">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>Apache在启动时获取用于解密私钥文件密语的方式</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLPassPhraseDialog <em>type</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLPassPhraseDialog builtin</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>Apache启动时必须读取私钥，而出于安全考虑私钥通常使用密语进行加密，Apache必须知道密语才能成功读取私钥。获取密语的<em>方式</em>有以下几种：</p>
<ul>
<li><code>builtin</code>
    <p>这是默认值。当Apache启动时在脱离终端前提示输入密语，管理员必须手动输入。因为可能存在多个不同的私钥(为每个不同的SSL虚拟主机分别配置了不同的私钥)，所以为了减少管理员的输入，Apache会在解密下一个私钥前尝试前面已经输入过的所有密语，如果能够成功解密，那么将不再提示输入。</p>
    <p>这个策略既允许最大的适应性(为每个私钥使用不同的密语)也允许最小化谜语输入次数(可以为所有私钥都是用相同的密语)。</p></li>

<li><code>|/path/to/program [args...]</code> 

   <p>这个方式使用一个外部程序作为通向特定输入设备的管道，Apache将会向这个程序的<code>stdin</code>发送<code>builtin</code>方式时显示的提示信息并期望这个程序向<code>stdout</code>输出所需要的密语。如果需要输入多个密语(或者输入了一个错误的密语)，将会再次发送额外的提示信息。</p></li>

<li><code>exec:/path/to/program</code>
    <p>这种方式将在Apache启动时为每个密语未知的私钥调用一次外部程序，每次调用使用两个参数：①"<code>servername:portnumber</code>"、②"<code>RSA</code>"或"<code>DSA</code>"。这个程序应该将相应的密语输出到<code>stdout</code>。这样设计的意图是希望这个程序首先对系统进行检查，确认系统没有遭到入侵后才输出密语。</p>
    <p>至于检查过程如何设计、密语如何生成，完全是你的自由，但是输出到<code>stdout</code>的内容却只能正好是密语的内容，一个字不能多也一个字不能少！</p>
    <p>同样，前面的密语复用策略在这里也同样生效。也就是说，仅在尝试了先前输入的所有密语都失败后才会调用此程序。</p></li>
</ul>
<div class="example"><h3>示例</h3><p><code>SSLPassPhraseDialog exec:/usr/local/apache/sbin/pp-filter</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProtocol" id="SSLProtocol">SSLProtocol</a> <a name="sslprotocol" id="sslprotocol">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>指定允许使用哪些版本的SSL协议</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProtocol [+|-]<em>protocol</em> ...</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLProtocol all</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>Options</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令用于控制mod_ssl允许使用哪些版本的SSL协议，这样客户端就只能使用被允许的协议。</p>
<p>可用的协议版本如下：</p>
<ul>
<li><code>SSLv2</code></li>

<li><code>SSLv3</code></li>

<li><code>TLSv1</code></li>

<li><code>All</code>(等价于"<code>+SSLv2 +SSLv3 +TLSv1</code>")</li>
</ul>
<div class="example"><h3>示例</h3><p><code>
#允许使用SSLv3和TLSv1但不允许使用SSLv2<br />
SSLProtocol all -SSLv2
</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProxyCACertificateFile" id="SSLProxyCACertificateFile">SSLProxyCACertificateFile</a> <a name="sslproxycacertificatefile" id="sslproxycacertificatefile">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于远端服务器认证的多合一CA证书(PEM格式)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProxyCACertificateFile <em>file-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令用于远端服务器认证。这个指令指定了一个<em>多合一</em>的CA证书，只有持有这些CA所签发证书的<em>远端服务器</em>才允许代理。这个所谓"多合一"证书文件其实就是将多个PEM格式的证书按照优先级顺序放置在同一个文件中而已。这个指令也可以由<code class="directive"><a href="#sslproxycacertificatepath">SSLProxyCACertificatePath</a></code>指令代替，或者两个一起使用。</p>
<div class="example"><h3>示例</h3><p><code>SSLProxyCACertificateFile /usr/local/apache2/conf/ssl.crt/ca-bundle-remote-server.crt</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProxyCACertificatePath" id="SSLProxyCACertificatePath">SSLProxyCACertificatePath</a> <a name="sslproxycacertificatepath" id="sslproxycacertificatepath">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于远端服务器认证的CA证书(PEM格式)目录</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProxyCACertificatePath <em>directory-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令用于远端服务器认证。这个指令指定了一个包含CA证书的目录，只有持有这些CA所签发证书的<em>远端服务器</em>才允许代理。</p>
<p>该目录中的证书必须是PEM格式，并且它们都通过散列后的文件名访问。所以你不能只是把证书放到这个目录中就完事了：你还需要创建一个名为<em>hash-value</em><code>.N</code>的符号连接，并保证这个目录下的所有符号链接都准确无误。请使用mod_ssl附带的<code>Makefile</code>完成这项工作。</p>
<div class="example"><h3>示例</h3><p><code>SSLProxyCACertificatePath /usr/local/apache2/conf/ssl.crt/</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProxyCARevocationFile" id="SSLProxyCARevocationFile">SSLProxyCARevocationFile</a> <a name="sslproxycarevocationfile" id="sslproxycarevocationfile">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于远端服务器认证的多合一CA证书撤销列表(PEM格式)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProxyCARevocationFile <em>file-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令用于远端服务器认证。这个指令指定了一个<em>多合一</em>的CA证书撤销列表(CRL,Certificate Revocation Lists)，CRL中的证书都被视为无效证书。这个所谓"多合一"的CRL文件其实就是将多个PEM格式的CRL按照优先级顺序放置在同一个文件中而已。这个指令也可以由<code class="directive"><a href="#sslproxycarevocationpath">SSLProxyCARevocationPath</a></code>指令代替，或者两个一起使用。</p>
<div class="example"><h3>示例</h3><p><code>SSLProxyCARevocationFile /usr/local/apache2/conf/ssl.crl/ca-bundle-remote-server.crl</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProxyCARevocationPath" id="SSLProxyCARevocationPath">SSLProxyCARevocationPath</a> <a name="sslproxycarevocationpath" id="sslproxycarevocationpath">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于远端服务器认证的CA证书撤销列表(PEM格式)目录</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProxyCARevocationPath <em>directory-path</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令用于远端服务器认证。这个指令指定了一个包含多个CA证书撤销列表(CRL)的目录，CRL中的证书都被视为无效证书。</p>
<p>该目录中的CRL必须是PEM格式，并且它们都通过散列后的文件名访问。所以你不能只是把CRL文件放到这个目录中就完事了：你还需要创建一个名为<em>hash-value</em><code>.rN</code>的符号连接，并保证这个目录下的所有符号链接都准确无误。请使用mod_ssl附带的<code>Makefile</code>完成这项工作。</p>
<div class="example"><h3>示例</h3><p><code>SSLProxyCARevocationPath /usr/local/apache2/conf/ssl.crl/</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProxyCipherSuite" id="SSLProxyCipherSuite">SSLProxyCipherSuite</a> <a name="sslproxyciphersuite" id="sslproxyciphersuite">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>允许远端服务器使用哪些加密算法套件</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProxyCipherSuite <em>cipher-spec</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLProxyCipherSuite ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令和<code>SSLCipherSuite</code>一样，唯一的不同之处就是它作用于到远端服务器的SSL连接。请参考<code class="directive"><a href="#sslciphersuite">SSLCipherSuite</a></code>指令以获取更多细节。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProxyEngine" id="SSLProxyEngine">SSLProxyEngine</a> <a name="sslproxyengine" id="sslproxyengine">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>SSL代理引擎开关</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProxyEngine on|off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLProxyEngine off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令用于开启或关闭SSL/TLS协议代理引擎。一般用于<code class="directive"><a href="../mod/core.html#virtualhost">&lt;VirtualHost&gt;</a></code>段中针对特定的虚拟主机开启SSL/TLS协议代理引擎。无论对于主服务器还是虚拟主机，SSL/TLS协议代理引擎都是默认关闭的。</p>
<div class="example"><h3>示例</h3><p><code>
&lt;VirtualHost _default_:443&gt;<br />
SSLProxyEngine on<br />
...<br />
&lt;/VirtualHost&gt;
</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProxyMachineCertificateFile" id="SSLProxyMachineCertificateFile">SSLProxyMachineCertificateFile</a> <a name="sslproxymachinecertificatefile" id="sslproxymachinecertificatefile">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>SSL代理客户端证书及私钥(PEM格式)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProxyMachineCertificateFile <em>filename</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>Not applicable</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>该指令指定了一个同时包含证书及相应私钥的<em>多合一</em>文件，用于向远端服务器标识自己的SSL代理身份。</p>
<p>这个所谓"多合一"文件其实就是将多个PEM格式的证书及相应私钥按照优先级顺序放置在同一个文件中而已。这个指令也可以由<code class="directive"><a href="#SSLProxyMachineCertificatePath">SSLProxyMachineCertificatePath</a></code>指令代替，或者两个一起使用。</p>
<div class="warning"><p>目前尚不支持经过密语加密的私钥。</p></div>
<div class="example"><h3>示例</h3><p><code>SSLProxyMachineCertificateFile /usr/local/apache2/conf/ssl.crt/proxy.pem</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProxyMachineCertificatePath" id="SSLProxyMachineCertificatePath">SSLProxyMachineCertificatePath</a> <a name="sslproxymachinecertificatepath" id="sslproxymachinecertificatepath">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>SSL代理客户端证书及私钥(PEM格式)目录</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProxyMachineCertificatePath <em>directory</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>Not applicable</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令指定了一个目录，存放同时包含证书及相应私钥的文件，用于向远端服务器标识自己的SSL代理身份。</p>
<p>该目录中的文件必须是PEM格式，并且它们都通过散列后的文件名访问。所以你不能只是把文件放到这个目录中就完事了：你还需要创建一个名为<code><em>hash-value</em>.N</code>的符号连接，并保证这个目录下的所有符号链接都准确无误。请使用mod_ssl附带的Makefile完成这项工作。</p>
<div class="warning"><p>目前尚不支持经过密语加密的私钥。</p></div>
<div class="example"><h3>示例</h3><p><code>SSLProxyMachineCertificatePath /usr/local/apache2/conf/proxy.crt/</code></p></div> 

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProxyProtocol" id="SSLProxyProtocol">SSLProxyProtocol</a> <a name="sslproxyprotocol" id="sslproxyprotocol">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>允许代理哪些版本的SSL协议</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProxyProtocol [+|-]<em>protocol</em> ...</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLProxyProtocol all</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>Options</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令指定了允许代理哪些版本的SSL协议。</p>
<p>请参考<code class="directive"><a href="#sslprotocol">SSLProtocol</a></code>指令以获得更多详情。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProxyVerify" id="SSLProxyVerify">SSLProxyVerify</a> <a name="sslproxyverify" id="sslproxyverify">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>对远端服务器证书的验证级别</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProxyVerify <em>level</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLProxyVerify none</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令指定了充当SSL代理的Apache如何对被代理的远端服务器证书进行验证。该指令既可以用于主机级别的配置(在SSL握手阶段就按照指定的级别进行证书验证)，也可以用于目录级别的配置(在收到HTTP请求后、发送HTTP应答前，强制使用新的验证级别进行SSL重协商)。</p>

<div class="warning">
<p>主意：即使启用了证书验证，<code class="module"><a href="../mod/mod_ssl.html">mod_ssl</a></code>也<strong>不会</strong>检查远端服务器证书的<code>commonName</code>(hostname)属性值是否确实与其主机名相同。换句话说，SSL代理并不保证到后端服务器的SSL连接是"安全"的，即使其证书是由<code class="directive">SSLProxyCACertificatePath</code>和/或<code class="directive">SSLProxyCACertificateFile</code>中指定的一个CA签发的。</p>
</div>

<p>可用的<em>level</em>如下：</p>
<ul>
<li><strong>none</strong>: 根本<em>不要求</em>远端服务器持有证书</li>
<li><strong>optional</strong>: 远端服务器<em>可以</em>持有一个有效的证书</li>
<li><strong>require</strong>: 远端服务器<em>必须</em>持有一个有效的证书</li>
<li><strong>optional_no_ca</strong>: 远端服务器<em>可以</em>持有一个有效的证书，但是并不需要成功的通过验证。</li>
</ul>
<p>在实践中，只有<strong>none</strong>和<strong>require</strong>有实际意义，因为<strong>optional</strong>并不能和所有远端服务器正常工作，而<strong>optional_no_ca</strong>实际上依赖于身份认证的思想(但是可以用于SSL测试页面等)。</p>
<div class="example"><h3>示例</h3><p><code>SSLProxyVerify require</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLProxyVerifyDepth" id="SSLProxyVerifyDepth">SSLProxyVerifyDepth</a> <a name="sslproxyverifydepth" id="sslproxyverifydepth">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>验证远端服务器证书有效性时允许的最大证书链深度</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLProxyVerifyDepth <em>number</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLProxyVerifyDepth 1</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令设置了在判定远端服务器证书无效前，允许验证的最大证书链深度。这个指令既可以用于主机级别的配置(在SSL握手阶段就按照指定的深度进行验证)，也可以用于目录级别的配置(在收到HTTP请求后、发送HTTP应答前，强制使用新的验证深度进行SSL重协商)。</p>
<p>这里所谓的"最大深度"其实是指证书链上中间CA的最大个数。"0"表示仅接受自签名证书。默认值"1"表示只接受自签名证书和已知CA直接签名的证书。这里所谓的"已知CA"是指该CA的证书位于<code class="directive"><a href="#sslproxycacertificatepath">SSLProxyCACertificatePath</a></code>目录中。</p>
<div class="example"><h3>示例</h3><p><code>SSLProxyVerifyDepth 10</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLRandomSeed" id="SSLRandomSeed">SSLRandomSeed</a> <a name="sslrandomseed" id="sslrandomseed">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>指定伪随机数生成器(PRNG)的随机数种子源</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLRandomSeed <em>context</em> <em>source</em> [<em>bytes</em>]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>指定在OpenSSL启动时(<em>context</em>=<code>startup</code>)和/或在建立新SSL连接时(<em>context</em>=<code>connect</code>)供伪随机数生成器(PRNG)使用的随机数种子源(一个或多个)。因为PRNG是一个全局设施，所以该指令只能用于服务器全局配置。</p>
<p>可用的<em>source</em>类型如下：</p>
<ul>
<li><code>builtin</code>
    <p>这是永远可用的内置源。它在运行时只使用很少的CPU资源，因此是非常优秀的源。它的随机性来自于当前时间、当前进程的PID、从Apache的inter-process scoreboard structure中随机提取的1KB数据(如果可用的话)。其缺点是随机性不够强，并且在启动时(此时scoreboard尚不可用)所能得到的随机位较少。所以你应该总是(至少对于<code>startup</code>)使用外部随机数源。</p></li>
<li><code>file:/path/to/source</code>
    <p>使用外部文件<code>/path/to/source</code>作为随机数种子源。如果指定了<em>bytes</em>，那么仅读取该文件开头的<em>bytes</em>字节作为随机位，否则将读取该文件的全部内容。推荐将其用于<code>startup</code>的情况，比如<code>/dev/random</code>和/或<code>/dev/urandom</code>设备，他们在现代类Unix系统(Linux,BSD)上都是可用的。</p>
    <p><em>但是请注意</em>：<code>/dev/random</code>设备仅提供其实际拥有的随机位。比如你需要512位随机数，但该设备目前实际只有100位随机位，那么根据不同的操作系统，将只可能有两种结果：①只提供100位；②读取操作将会被一直阻塞到能够提供512位为止(可能会花上很长一段时间)。因此，更明智的选择是使用<code>/dev/urandom</code>设备，因为它从不阻塞，并且总是能够返回足够多的随机位。其唯一的缺点就是随机位的质量没有<code>/dev/random</code>高。</p>
    <p>在某些平台上(比如FreeBSD)，你甚至可以控制随机位通过哪个系统中断生成，更多信息请查看相应平台上的<em>rndcontrol(8)</em>程序。作为替代方案，如果你的系统上没有随机设备，你可以使用类似<a href="http://www.lothar.com/tech/crypto/">EGD</a>这样的工具，并使用<code>exec:/path/to/program/</code>的方式运行其客户端，或者使用<code>egd:/path/to/egd-socket</code>，具体参见下文。</p></li>

<li><code>exec:/path/to/program</code>
    <p>使用外部可执行程序<code>/path/to/program</code>作为随机数种子源(比如下面示例中的<code>truerand</code>工具)。如果指定了<em>bytes</em>，那么仅读取输出到<code>stdout</code>上的前<em>bytes</em>字节作为随机位，否则将读取全部内容。建议仅将其用于<code>startup</code>需要强随机数的情况；如果用于<code>connect</code>的话，会大大拖慢服务器速度，请勿使用。</p></li>
<li><code>egd:/path/to/egd-socket</code>(Unix only)
    <p>使用<a href="http://www.lothar.com/tech/crypto/">EGD</a>的外部Unix domain socket作为作为随机数种子源。仅在你的操作系统没有随机设备支持的情况下使用。</p></li>
</ul>
<div class="example"><h3>示例</h3><p><code>
SSLRandomSeed startup builtin<br />
SSLRandomSeed startup file:/dev/random<br />
SSLRandomSeed startup file:/dev/urandom 1024<br />
SSLRandomSeed startup exec:/usr/local/bin/truerand 16<br />
SSLRandomSeed connect builtin<br />
SSLRandomSeed connect file:/dev/random<br />
SSLRandomSeed connect file:/dev/urandom 1024<br />
</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLRequire" id="SSLRequire">SSLRequire</a> <a name="sslrequire" id="sslrequire">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>仅在逻辑表达式<em>expression</em>的值为true的时候才允许SSL访问</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLRequire <em>expression</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令指定了一个访问控制条件，仅在条件满足的时候才允许SSL访问。这是一个非常强大的指令，因为其后所跟的表达式可以非常复杂。</p>
<div class="warning">
<p><code>SSLRequire</code>的实现并不是线程安全的，所以当使用线程型的<a href="../mpm.html">MPM</a>的时候，如果在<code>.htaccess</code>中使用<code>SSLRequire</code>指令可能会导致随机性的进程崩溃。</p>
</div>
<p><em>expression</em>必须使用下面的巴科斯范式语法([译者注]几乎每种编程语言书籍都使用巴科斯范式来定义编程语言的语法规则，如果你看不懂，可以STFW"巴科斯范式")：</p>
<blockquote>
<pre>
expr     ::= "<strong>true</strong>" | "<strong>false</strong>"
           | "<strong>!</strong>" expr
           | expr "<strong>&amp;&amp;</strong>" expr
           | expr "<strong>||</strong>" expr
           | "<strong>(</strong>" expr "<strong>)</strong>"
           | comp

comp     ::= word "<strong>==</strong>" word | word "<strong>eq</strong>" word
           | word "<strong>!=</strong>" word | word "<strong>ne</strong>" word
           | word "<strong>&lt;</strong>"  word | word "<strong>lt</strong>" word
           | word "<strong>&lt;=</strong>" word | word "<strong>le</strong>" word
           | word "<strong>&gt;</strong>"  word | word "<strong>gt</strong>" word
           | word "<strong>&gt;=</strong>" word | word "<strong>ge</strong>" word
           | word "<strong>in</strong>" "<strong>{</strong>" wordlist "<strong>}</strong>"
           | word "<strong>in</strong>" "<strong>OID(</strong>" word "<strong>)</strong>"
           | word "<strong>=~</strong>" regex
           | word "<strong>!~</strong>" regex

wordlist ::= word
           | wordlist "<strong>, </strong>" word

word     ::= digit
           | cstring
           | variable
           | function

digit    ::= [0-9]+
cstring  ::= "..."
variable ::= "<strong>%{</strong>" varname "<strong>}</strong>"
function ::= funcname "<strong>(</strong>" funcargs "<strong>)</strong>"
</pre>
</blockquote>
<p><code>varname</code>是<a href="#table3">表3</a>中的任意一个变量。<code>funcname</code>可以使用下列函数：</p>
<ul>
<li><code>file(</code><em>filename</em><code>)</code>
    <p>这个函数接受一个文件名作为参数并将其展开为文件的内容。比如可以用于需要使用一个正则表达式对文件内容进行匹配的场合。</p>
</li>
</ul>
<p>主意：<em>expression</em>首先被解析成一种内部表示法，然后再进行评估。事实上，对于全局性的设置和虚拟主机级别的设置，<em>expression</em>将在服务器启动的时候被解析成内部表示法，然后在运行时进行实时评估。而目录级的配置则不同：<em>expression</em>必须对每个请求进行实时解析和评估。</p>
<div class="example"><h3>示例</h3><p><code>
SSLRequire (    %{SSL_CIPHER} !~ m/^(EXP|NULL)-/ \<br />
            and %{SSL_CLIENT_S_DN_O} eq "Snake Oil, Ltd." \<br />
            and %{SSL_CLIENT_S_DN_OU} in {"Staff", "CA", "Dev"} \<br />
            and %{TIME_WDAY} &gt;= 1 and %{TIME_WDAY} &lt;= 5 \<br />
            and %{TIME_HOUR} &gt;= 8 and %{TIME_HOUR} &lt;= 20       ) \<br />
           or %{REMOTE_ADDR} =~ m/^192\.76\.162\.[0-9]+$/
</code></p></div>
<p><code>OID()</code>函数会企图找到零个或更多客户端证书OID的实例，并用左侧的字符串和匹配的OID属性值进行比较。每一个匹配的OID都会被检查，只到找到一个匹配。</p>

<p><em>标准CGI/1.0和Apache变量：</em></p>
<pre>
HTTP_USER_AGENT        PATH_INFO             AUTH_TYPE
HTTP_REFERER           QUERY_STRING          SERVER_SOFTWARE
HTTP_COOKIE            REMOTE_HOST           API_VERSION
HTTP_FORWARDED         REMOTE_IDENT          TIME_YEAR
HTTP_HOST              IS_SUBREQ             TIME_MON
HTTP_PROXY_CONNECTION  DOCUMENT_ROOT         TIME_DAY
HTTP_ACCEPT            SERVER_ADMIN          TIME_HOUR
HTTP:headername        SERVER_NAME           TIME_MIN
THE_REQUEST            SERVER_PORT           TIME_SEC
REQUEST_METHOD         SERVER_PROTOCOL       TIME_WDAY
REQUEST_SCHEME         REMOTE_ADDR           TIME
REQUEST_URI            REMOTE_USER           ENV:<strong>variablename</strong>
REQUEST_FILENAME
</pre>
<p><em>SSL相关的变量：</em></p>
<pre>
HTTPS                  SSL_CLIENT_M_VERSION   SSL_SERVER_M_VERSION
                       SSL_CLIENT_M_SERIAL    SSL_SERVER_M_SERIAL
SSL_PROTOCOL           SSL_CLIENT_V_START     SSL_SERVER_V_START
SSL_SESSION_ID         SSL_CLIENT_V_END       SSL_SERVER_V_END
SSL_CIPHER             SSL_CLIENT_S_DN        SSL_SERVER_S_DN
SSL_CIPHER_EXPORT      SSL_CLIENT_S_DN_C      SSL_SERVER_S_DN_C
SSL_CIPHER_ALGKEYSIZE  SSL_CLIENT_S_DN_ST     SSL_SERVER_S_DN_ST
SSL_CIPHER_USEKEYSIZE  SSL_CLIENT_S_DN_L      SSL_SERVER_S_DN_L
SSL_VERSION_LIBRARY    SSL_CLIENT_S_DN_O      SSL_SERVER_S_DN_O
SSL_VERSION_INTERFACE  SSL_CLIENT_S_DN_OU     SSL_SERVER_S_DN_OU
                       SSL_CLIENT_S_DN_CN     SSL_SERVER_S_DN_CN
                       SSL_CLIENT_S_DN_T      SSL_SERVER_S_DN_T
                       SSL_CLIENT_S_DN_I      SSL_SERVER_S_DN_I
                       SSL_CLIENT_S_DN_G      SSL_SERVER_S_DN_G
                       SSL_CLIENT_S_DN_S      SSL_SERVER_S_DN_S
                       SSL_CLIENT_S_DN_D      SSL_SERVER_S_DN_D
                       SSL_CLIENT_S_DN_UID    SSL_SERVER_S_DN_UID
                       SSL_CLIENT_S_DN_Email  SSL_SERVER_S_DN_Email
                       SSL_CLIENT_I_DN        SSL_SERVER_I_DN
                       SSL_CLIENT_I_DN_C      SSL_SERVER_I_DN_C
                       SSL_CLIENT_I_DN_ST     SSL_SERVER_I_DN_ST
                       SSL_CLIENT_I_DN_L      SSL_SERVER_I_DN_L
                       SSL_CLIENT_I_DN_O      SSL_SERVER_I_DN_O
                       SSL_CLIENT_I_DN_OU     SSL_SERVER_I_DN_OU
                       SSL_CLIENT_I_DN_CN     SSL_SERVER_I_DN_CN
                       SSL_CLIENT_I_DN_T      SSL_SERVER_I_DN_T
                       SSL_CLIENT_I_DN_I      SSL_SERVER_I_DN_I
                       SSL_CLIENT_I_DN_G      SSL_SERVER_I_DN_G
                       SSL_CLIENT_I_DN_S      SSL_SERVER_I_DN_S
                       SSL_CLIENT_I_DN_D      SSL_SERVER_I_DN_D
                       SSL_CLIENT_I_DN_UID    SSL_SERVER_I_DN_UID
                       SSL_CLIENT_I_DN_Email  SSL_SERVER_I_DN_Email
                       SSL_CLIENT_A_SIG       SSL_SERVER_A_SIG
                       SSL_CLIENT_A_KEY       SSL_SERVER_A_KEY
                       SSL_CLIENT_CERT        SSL_SERVER_CERT
                       SSL_CLIENT_CERT_CHAIN_<strong>n</strong>
                       SSL_CLIENT_VERIFY
</pre>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLRequireSSL" id="SSLRequireSSL">SSLRequireSSL</a> <a name="sslrequiressl" id="sslrequiressl">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>禁止未使用SSL的HTTP请求</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLRequireSSL</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令用于禁止未使用SSL的HTTP请求，也就是必须使用HTTPS进行访问。它可以方便的用于避免被SSL保护的虚拟主机或目录由于配置错误而允许通过未加密的HTTP进行访问。只要这个指令存在，任何不使用SSL加密的连接都将被拒绝。</p>
<div class="example"><h3>示例</h3><p><code>SSLRequireSSL</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLSessionCache" id="SSLSessionCache">SSLSessionCache</a> <a name="sslsessioncache" id="sslsessioncache">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>指定SSL会话缓存的类型</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLSessionCache <em>type</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLSessionCache none</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令指定了全局/进程间SSL会话缓存的类型。SSL会话缓存机制(可选的)可以加速对并发HTTPS请求的处理速度。对于同一个服务器进程处理的HTTP keep-alive连接，OpenSSL自身已经在本地缓存了SSL会话信息。但是由于现代浏览器会使用多个并发连接请求页面内的图片等其他资源，服务器就不得不使用<em>不同</em>的进程来处理这些连接，因此能够在不同进程之间缓存SSL会话信息就有助于避免不必要的握手过程。</p>
<p>目前可用的缓存<em>type</em>如下：</p>
<ul>
<li><code>none</code>

    <p>彻底禁止使用会话缓存。这将会导致服务器处理速度明显降低，并且在某些浏览器上会出现故障(特别是启用了客户端认证的时候)。因此，我们反对关闭缓存。</p></li>

<li><code>nonenotnull</code>

    <p>彻底禁止使用会话缓存，但是它强迫OpenSSL向客户端发送一个非空的会话ID，这样就可以和有bug的浏览器一起工作了。</p></li>

<li><code>dbm:/path/to/datafile</code>

    <p>使用一个本地磁盘上的DBM哈希文件缓存SSL会话信息。这种方式在高负载的情况下可能会遭遇可靠性问题。</p></li>

<li><code>shm:/path/to/datafile</code>[<code>(</code><em>size</em><code>)</code>]

    <p>使用高性能的共享内存文件(<em>size</em>字节大小的<code>/path/to/datafile</code>文件)作为循环缓冲区缓存SSL会话信息。这是推荐的方式。</p></li>

<li><code>dc:UNIX:/path/to/socket</code>

    <p>利用分布式的<a href="http://www.distcache.org/">distcache</a>会话缓存库缓存SSL会话信息。应该在参数中使用distcache地址语法规范来指定服务器或代理的位置。例如，使用"<code>UNIX:/path/to/socket</code>"指定一个UNIX domain socket(一般是一个本地dc_client代理)，使用"<code>IP:server.example.com:9001</code>"指定一个IP地址。</p></li>

</ul>
<div class="example"><h3>例子</h3><p><code>
SSLSessionCache dbm:/usr/local/apache/logs/ssl_gcache_data<br />
SSLSessionCache shm:/usr/local/apache/logs/ssl_gcache_data(512000)
</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLSessionCacheTimeout" id="SSLSessionCacheTimeout">SSLSessionCacheTimeout</a> <a name="sslsessioncachetimeout" id="sslsessioncachetimeout">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>指定SSL会话缓存的有效期</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLSessionCacheTimeout <em>seconds</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLSessionCacheTimeout 300</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令用于设置SSL会话缓存的有效期(秒)。在测试的时候可以设置一个较小的值(比如15)，但是建议在生产环境中设置成一个较大的值(比如300)。</p>
<div class="example"><h3>示例</h3><p><code>SSLSessionCacheTimeout 600</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLUserName" id="SSLUserName">SSLUserName</a> <a name="sslusername" id="sslusername">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于确定用户名的SSL变量名</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLUserName <em>varname</em></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.0.51 及以后的版本中可用</td></tr>
</table>
<p>这个指令用于设置Apache请求对象的"user"字段的值。这个值被下层模块用来标识用户。特别地，这将导致环境变量<code>REMOTE_USER</code>被设置。<em>varname</em>可以是任意一个<a href="#envvars">SSL环境变量</a>。</p>

<p>需要注意的是，当使用了<code>FakeBasic</code>选项的时候(参见<a href="#ssloptions">SSLOptions</a>)，这个指令没有任何效果。</p>

<div class="example"><h3>示例</h3><p><code>SSLUserName SSL_CLIENT_S_DN_CN</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLVerifyClient" id="SSLVerifyClient">SSLVerifyClient</a> <a name="sslverifyclient" id="sslverifyclient">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>客户端证书的验证级别</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLVerifyClient <em>level</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLVerifyClient none</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令设置了对客户端证书的验证级别。该指令既可以用于主机级别的配置(在SSL握手阶段就按照指定的级别进行证书验证)，也可以用于目录级别的配置(在收到HTTP请求后、发送HTTP应答前，强制使用新的验证级别进行SSL重协商)。</p>
<p>可用的<em>level</em>如下：</p>
<ul>
<li><strong>none</strong>: 根本<em>不要求</em>客户端持有证书</li>
<li><strong>optional</strong>: 客户端<em>可以</em>持有一个有效的证书</li>
<li><strong>require</strong>: 客户端<em>必须</em>持有一个有效的证书</li>
<li><strong>optional_no_ca</strong>: 客户端<em>可以</em>持有一个有效的证书，但是并不需要成功的通过验证。</li>
</ul>
<p>在实践中，只有<strong>none</strong>和<strong>require</strong>有实际意义，因为<strong>optional</strong>并不能和所有浏览器协同工作，而<strong>optional_no_ca</strong>实际上依赖于身份认证的思想(但是可以用于SSL测试页面等)。</p>
<div class="example"><h3>示例</h3><p><code>
SSLVerifyClient require
</code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SSLVerifyDepth" id="SSLVerifyDepth">SSLVerifyDepth</a> <a name="sslverifydepth" id="sslverifydepth">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>验证客户端证书有效性时允许的最大证书链深度</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SSLVerifyDepth <em>number</em></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>SSLVerifyDepth 1</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>扩展(E)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>mod_ssl</td></tr>
</table>
<p>这个指令设置了在判定客户端证书无效前，允许验证的最大证书链深度。这个指令既可以用于主机级别的配置(在SSL握手阶段就按照指定的深度进行验证)，也可以用于目录级别的配置(在收到HTTP请求后、发送HTTP应答前，强制使用新的验证深度进行SSL重协商)。</p>
<p>这里所谓的"最大深度"其实是指证书链上中间CA的最大个数。"0"表示仅接受自签名证书。默认值"1"表示只接受自签名证书和已知CA直接签名的证书。这里所谓的"已知CA"是指该CA的证书位于<code class="directive"><a href="#sslcacertificatepath">SSLCACertificatePath</a></code>目录中。</p>
<div class="example"><h3>示例</h3><p><code>SSLVerifyDepth 10</code></p></div>

</div>
</div>
<div id="footer">
<p class="apache">本文允许自由使用、分发、转载，但必须保留译者署名；详见：<a href="../translator_announcement.html#announcement">译者声明</a>。</p>
<p class="menu"><a href="../mod/index.html">模块索引</a> | <a href="../mod/directives.html">指令索引</a> | <a href="../faq/index.html">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">站点导航</a></p></div>
</body></html>
