<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Language" content="zh-CN" />
<meta name="keywords" content="Apache, 中文, 手册, 中文版, 中文手册, 中文版手册, 参考手册, 中文参考手册, 金步国" />
<meta name="description" content="Apache 2.2 中文版参考手册" />
<meta name="author" content="金步国" />
<link href="../style/css/manual-zip.css" rel="stylesheet" media="all" type="text/css" title="Main stylesheet" />
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" media="all" type="text/css" title="No Sidebar - Default font size" />
<link href="../style/css/manual-print.css" rel="stylesheet" media="print" type="text/css" />
<title>Apache核心(Core)特性 － Apache 2.2 中文版参考手册</title>
</head>
<body><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块索引</a> | <a href="../mod/directives.html">指令索引</a> | <a href="../faq/index.html">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">站点导航</a></p><p class="apache">Apache HTTP Server 版本2.2</p><img alt="" src="../images/feather.gif" /></div>
<div class="up"><a href="./index.html"><img title="&lt;-" alt="&lt;-" src="../images/left.gif" /></a></div>
<div id="path"><a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP Server</a> &gt; <a href="http://httpd.apache.org/docs/">文档</a> &gt; <a href="../index.html">版本2.2</a> &gt; <a href="./index.html">模块</a></div>

<div id="translation-info">　　 <a href="../translator_announcement.html#thanks">致谢</a> | 本篇译者：<a href="http://lamp.linux.gov.cn/jinbuguo_florilegium.html">金步国</a>(<a href="http://lamp.linux.gov.cn/jinbuguo_florilegium.html">其他作品</a>) | 本页最后更新：2007年4月4日[<a href="../translator_announcement.html#last_new" style="color:#F91C58">查看最新版本</a>] <a href="http://lamp.linux.gov.cn/Apache/ApacheMenu/index.html">电信镜像</a> <a href="http://lapp.unixmap.net/Apache/ApacheMenu/index.html">网通镜像</a></div>
<div id="page-content"><div id="preamble"><h1>Apache核心(Core)特性</h1>

<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="module">
<tr><th><a href="module-dict.html#Description">说明</a></th><td>Apache HTTP服务器核心提供的功能，始终有效</td></tr>
<tr><th><a href="module-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
</table>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="AcceptFilter" id="AcceptFilter">AcceptFilter</a> <a name="acceptfilter" id="acceptfilter">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>根据协议类型对监听Socket进行优化</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>AcceptFilter <var>protocol</var> <var>accept_filter</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.1.5 以后的版本中可用</td></tr>
</table>
    <p>这个指令使得操作系统根据协议类型对监听socket进行特别的优化。其基本前提是内核在数据接受完毕或一个完整的HTTP请求缓冲完成前不向服务器进程发送socket 。目前仅支持<a href="http://www.freebsd.org/cgi/man.cgi?query=accept_filter&amp;sektion=9">FreeBSD的接收过滤器(Accept Filter)</a>和Linux的更原始的(more primitive)<code>TCP_DEFER_ACCEPT</code> 。</p>

    <p>FreeBSD上的默认值是：</p>
    <div class="example"><p><code>
        AcceptFilter http httpready <br />
        AcceptFilter https dataready
    </code></p></div>
    
    <p><code>httpready</code>接收过滤器(Accept Filter)在内核级别缓冲整个HTTP请求。一旦一个请求体被完整接收，内核将把它发送给服务器。参见<a href="http://www.freebsd.org/cgi/man.cgi?query=accf_http&amp;sektion=9">accf_http(9)</a>手册页以获得更详细的信息。因为HTTPS请求已经被加密了，所以只使用了<a href="http://www.freebsd.org/cgi/man.cgi?query=accf_data&amp;sektion=9">accf_data(9)</a>过滤器。</p>

    <p>Linux上的默认值是：</p>
    <div class="example"><p><code>
        AcceptFilter http data <br />
        AcceptFilter https data
    </code></p></div>

    <p>Linux的<code>TCP_DEFER_ACCEPT</code>并不支持对http请求进行缓冲。除<code>none</code>之外的任何值都将在监听程序上启用<code>TCP_DEFER_ACCEPT</code> 。参见<a href="http://homepages.cwi.nl/~aeb/linux/man2html/man7/tcp.7.html">tcp(7)</a>手册页以获得更多详情。</p>

    <p>使用<code>none</code>将会为那个协议禁用接收过滤器(accept filter)。这对于像<code>nntp</code>这样需要服务器先发送数据的协议很有用处：</p>
    <div class="example"><p><code>AcceptFilter nttp none</code></p></div>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="AcceptPathInfo" id="AcceptPathInfo">AcceptPathInfo</a> <a name="acceptpathinfo" id="acceptpathinfo">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>是否接受附带多余路径名信息的请求</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>AcceptPathInfo On|Off|Default</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>AcceptPathInfo Default</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.0.30 及以后的版本中可用</td></tr>
</table>

    <p>此指令决定是否接受在实际文件名(或实际目录中一个不存在的文件)后跟随多余路径名信息的请求。这个多余的路径名信息可以当作<code>PATH_INFO</code>环境变量传递给脚本。</p>

    <p>比如说，假设<code>/test/</code>所指向的目录下只包括一个文件：<code>here.html</code> ，那么对<code>/test/here.html/more</code>和<code>/test/nothere.html/more</code>的请求都会将<code>PATH_INFO</code>环境变量设为"<code>/more</code>"。</p>

    <p><code class="directive">AcceptPathInfo</code>指令的取值范围：</p>
    <dl>
    <dt><code>Off</code></dt><dd>仅当一个请求映射到一个真实存在的路径时，才会被接受。这样，如上述<code>/test/here.html/more</code>这样在真实文件名后跟随一个路径名的请求将会返回一个"404 NOT FOUND"错误。</dd>

    <dt><code>On</code></dt><dd>只要前导路径可以映射到一个真实存在的文件，就可以接受该请求。这样，只要上述<code>/test/here.html</code>能够映射到一个有效的文件，那么对<code>/test/here.html/more</code>的请求就会被接收。</dd>

    <dt><code>Default</code></dt><dd>是否接收附带多余路径名信息的请求由其对应的<a href="../handler.html">处理器</a>来决定。对应普通文本的核心处理器默认会拒绝<code>PATH_INFO</code> 。而用于伺服脚本的处理器，比如<a href="mod_cgi.html">cgi-script</a>和<a href="mod_isapi.html">isapi-isa</a>，默认会接受<code>PATH_INFO</code> 。</dd>
    </dl>

    <p><code>AcceptPathInfo</code>指令存在的首要目的就是允许您覆盖处理器关于是否接受<code>PATH_INFO</code>的默认设置。这种覆盖是很必要的。比如说，当您使用了类似<a href="mod_include.html">INCLUDES</a>这样的<a href="../filter.html">过滤器</a>来根据<code>PATH_INFO</code>产生内容时。核心处理器通常会拒绝这样的请求，而您就可以用下述的配置使这样的脚本成为可能：</p>

    <div class="example"><p><code>
      &lt;Files "mypaths.shtml"&gt;<br />
      <span class="indent">
        Options +Includes<br />
        SetOutputFilter INCLUDES<br />
        AcceptPathInfo On<br />
      </span>
      &lt;/Files&gt;
    </code></p></div>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="AccessFileName" id="AccessFileName">AccessFileName</a> <a name="accessfilename" id="accessfilename">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>分布式配置文件的名字</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>AccessFileName <var>filename</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>AccessFileName .htaccess</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>如果<a href="#allowoverride">为某个目录启用了分布式配置文件功能</a>，那么在向客户端返回其中的文档时，服务器将在这个文档所在的各级目录中查找此配置文件。比如：</p>

    <div class="example"><p><code>
      AccessFileName .acl
    </code></p></div>

    <p>在返回文档<code>/usr/local/web/index.html</code>之前，服务器会为此指令读取 <code>/.acl</code> 、<code>/usr/.acl</code> 、<code>/usr/local/.acl</code> 、<code>/usr/local/web/.acl</code> 除非此功能以被如下配置所禁用：</p>

    <div class="example"><p><code>
      &lt;Directory /&gt;<br />
      <span class="indent">
        AllowOverride None<br />
      </span>
      &lt;/Directory&gt;
    </code></p></div>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#allowoverride">AllowOverride</a></code></li>
<li><a href="../configuring.html">配置文件</a></li>
<li><a href="../howto/htaccess.html">.htaccess 文件</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="AddDefaultCharset" id="AddDefaultCharset">AddDefaultCharset</a> <a name="adddefaultcharset" id="adddefaultcharset">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>当应答内容是<code>text/plain</code>或<code>text/html</code>时，在HTTP应答头中加入的默认字符集</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>AddDefaultCharset On|Off|<var>charset</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>AddDefaultCharset Off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>当且仅当应答内容是<code>text/plain</code>或<code>text/html</code>时，此指令将会在HTTP应答头中加入的默认字符集。理论上这将覆盖在文档体中通过<code>&lt;meta&gt;</code>标签指定的字符集，但是实际的行为通常取决于用户浏览器的设置。<code>AddDefaultCharset Off</code> 将会禁用此功能。<code>AddDefaultCharset On</code> 将启用Apache内部的默认字符集<code>iso-8859-1</code> 。您也可以指定使用<a href="http://www.iana.org/assignments/character-sets">在IANA注册过的字符集名字</a>中的另外一个<var>charset</var> 。比如说：</p>

    <div class="example"><p><code>
      AddDefaultCharset utf-8
    </code></p></div>

    <p><code class="directive">AddDefaultCharset</code>只应当在如下情况下使用：所有文本资源都使用同一种确定的字符集，且分别标记他们的字符集非常麻烦。一个这样的例子是向包含动态内容的资源中添加字符集参数(比如先前遗留的CGI脚本)，这样可能会因为在输出中包含用户提供的数据而导致跨站点脚本攻击。但是请注意：更好的解决办法是修改或删除这些脚本，因为设置了默认的字符集以后将会使得浏览器的字符集自动探测功能失效。</p>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="../mod/mod_mime.html#addcharset">AddCharset</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="AddOutputFilterByType" id="AddOutputFilterByType">AddOutputFilterByType</a> <a name="addoutputfilterbytype" id="addoutputfilterbytype">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>对特定的MIME类型指定输出过滤器</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>AddOutputFilterByType <var>filter</var>[;<var>filter</var>...] <var>MIME-type</var> [<var>MIME-type</var>] ...</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>Apache 2.0.33 以后可用，但在Apache 2.1 以后反对使用</td></tr>
</table>
    <p>此指令根据应答的<a class="glossarylink" href="../glossary.html#mime-type" title="see glossary">MIME类型</a>对请求激活特定的输出<a href="../filter.html">过滤器</a>。由于下面将要讨论的问题，我们反对使用这个指令。同样的功能可以通过使用<code class="module"><a href="../mod/mod_filter.html">mod_filter</a></code>模块获得。</p>

    <p>下例使用了由<code class="module"><a href="../mod/mod_deflate.html">mod_deflate</a></code>提供的<code>DEFLATE</code>过滤器。它将把所有以<code>text/html</code>或<code>text/plain</code>为标记的输出(不论静态或动态)在发送到客户端之前进行压缩。</p>

    <div class="example"><p><code>
      AddOutputFilterByType DEFLATE text/html text/plain
    </code></p></div>

    <p>如果您希望使用多个过滤器来处理内容，您可以用分号(;)来分隔它们的名字。并对每个过滤器使用<code class="directive">AddOutputFilterByType</code>指令。</p>

    <p>下述配置将使所有标记为<code>text/html</code>的脚本输出首先被<code>INCLUDES</code>过滤器处理后再被<code>DEFLATE</code>过滤器处理。</p>

    <div class="example"><p><code>
    &lt;Location /cgi-bin/&gt;<br />
    <span class="indent">
      Options Includes<br />
      AddOutputFilterByType INCLUDES;DEFLATE text/html<br />
    </span>
    &lt;/Location&gt;
    </code></p></div>

    <div class="warning"><h3>注意</h3>
      <p>在某些情况下，用<code class="directive">AddOutputFilterByType</code>来使用过滤器会遭受部分或完全的失败。比如，如果<a class="glossarylink" href="../glossary.html#mime-type" title="see glossary">MIME类型</a>不能确定，那么将不会有过滤器加于其上，从而使之回到<code class="directive"><a href="#defaulttype">DefaultType</a></code>的设置。甚至当<code class="directive"><a href="#defaulttype">DefaultType</a></code>与其相同的时候也是这样。</p>

      <p>然而，如果您想确认对某些资源相关的内容类型确实使用了过滤器，您可以使用用诸如<code class="directive"><a href="../mod/mod_mime.html#addtype">AddType</a></code>或<code class="directive"><a href="#forcetype">ForceType</a></code>这样的办法。在一个(non-nph)CGI脚本中设定内容类型也很安全。</p>

      <p>由类型决定的输出过滤器永远不会作用于来自代理的请求。</p>
    </div>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="../mod/mod_mime.html#addoutputfilter">AddOutputFilter</a></code></li>
<li><code class="directive"><a href="#setoutputfilter">SetOutputFilter</a></code></li>
<li><a href="../filter.html">过滤器</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="AllowEncodedSlashes" id="AllowEncodedSlashes">AllowEncodedSlashes</a> <a name="allowencodedslashes" id="allowencodedslashes">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>确定是否允许URL中使用经过编码的路径分割符</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>AllowEncodedSlashes On|Off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>AllowEncodedSlashes Off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.0.46 及以后的版本中可用</td></tr>
</table>
    <p><code class="directive">AllowEncodedSlashes</code>指令允许使用包含经过编码的路径分割符的URL("<code>%2F</code>"→"<code>/</code>"或"<code>%5C</code>"→"<code>\</code>"，取决于不同的系统)。默认情况下，这些URL将被一个包含"404"(未找到)错误的应答拒绝。</p>

    <p><code class="directive">AllowEncodedSlashes</code> <code>On</code> 通常和<code>PATH_INFO</code>配合使用。</p>

    <div class="note"><h3>注意</h3>
      <p>允许使用经过编码的斜线(路径分割符)<em>并不意味着解码</em>。<code>%2F</code>或<code>%5C</code>(<em>仅仅</em>取决于不同的系统)将会按原样出现在解码后的URL字符串中。</p>
    </div>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#acceptpathinfo">AcceptPathInfo</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="AllowOverride" id="AllowOverride">AllowOverride</a> <a name="allowoverride" id="allowoverride">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>确定允许存在于<code>.htaccess</code>文件中的指令类型</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>AllowOverride All|None|<var>directive-type</var>
[<var>directive-type</var>] ...</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>AllowOverride All</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>directory</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>当服务器发现一个<code>.htaccess</code>文件(由<code class="directive"><a href="#accessfilename">AccessFileName</a></code>指定)时，它需要知道在这个文件中声明的哪些指令能覆盖在此之前指定的配置指令。</p>

    <div class="note"><h3>仅允许存在于&lt;Directory&gt;配置段</h3>
    <code class="directive">AllowOverride</code>仅在不包含正则表达式的<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>配置段中才是有效的。在<code class="directive"><a href="#location">&lt;Location&gt;</a></code>, <code class="directive"><a href="#directorymatch">&lt;DirectoryMatch&gt;</a></code>, <code class="directive"><a href="#files">&lt;Files&gt;</a></code>配置段中都是无效的。</div>

    <p>如果此指令被设置为<code>None</code> ，那么<a href="#accessfilename">.htaccess</a>文件将被完全忽略。事实上，服务器根本不会读取<code>.htaccess</code>文件。</p>

    <p>当此指令设置为 <code>All</code>时，所有具有".htaccess"<a href="directive-dict.html#Context">作用域</a>的指令都允许出现在<code>.htaccess</code>文件中。</p>

    <p><var>directive-type</var>可以是下列各组指令之一：</p>

    <dl>
      <dt>AuthConfig</dt>
      <dd>允许使用与认证授权相关的指令(<code class="directive"><a href="../mod/mod_authn_dbm.html#authdbmgroupfile">AuthDBMGroupFile</a></code>, <code class="directive"><a href="../mod/mod_authn_dbm.html#authdbmuserfile">AuthDBMUserFile</a></code>, <code class="directive"><a href="../mod/mod_authz_groupfile.html#authgroupfile">AuthGroupFile</a></code>, <code class="directive"><a href="#authname">AuthName</a></code>, <code class="directive"><a href="#authtype">AuthType</a></code>, <code class="directive"><a href="../mod/mod_authn_file.html#authuserfile">AuthUserFile</a></code>, <code class="directive"><a href="#require">Require</a></code>, 等)。</dd>

      <dt>FileInfo</dt>
      <dd>允许使用控制文档类型的指令(<code class="directive"><a href="#defaulttype">DefaultType</a></code>, <code class="directive"><a href="#errordocument">ErrorDocument</a></code>, <code class="directive"><a href="#forcetype">ForceType</a></code>, <code class="directive"><a href="../mod/mod_negotiation.html#languagepriority">LanguagePriority</a></code>, <code class="directive"><a href="#sethandler">SetHandler</a></code>, <code class="directive"><a href="#setinputfilter">SetInputFilter</a></code>, <code class="directive"><a href="#setoutputfilter">SetOutputFilter</a></code>, <code class="module"><a href="../mod/mod_mime.html">mod_mime</a></code>中的 Add* 和 Remove* 指令等等)、控制文档元数据的指令(<code class="directive"><a href="../mod/mod_headers.html#header">Header</a></code>, <code class="directive"><a href="../mod/mod_headers.html#requestheader">RequestHeader</a></code>, <code class="directive"><a href="../mod/mod_setenvif.html#setenvif">SetEnvIf</a></code>, <code class="directive"><a href="../mod/mod_setenvif.html#setenvifnocase">SetEnvIfNoCase</a></code>, <code class="directive"><a href="../mod/mod_setenvif.html#browsermatch">BrowserMatch</a></code>, <code class="directive"><a href="../mod/mod_usertrack.html#cookieexpires">CookieExpires</a></code>, <code class="directive"><a href="../mod/mod_usertrack.html#cookiedomain">CookieDomain</a></code>, <code class="directive"><a href="../mod/mod_usertrack.html#cookiestyle">CookieStyle</a></code>, <code class="directive"><a href="../mod/mod_usertrack.html#cookietracking">CookieTracking</a></code>, <code class="directive"><a href="../mod/mod_usertrack.html#cookiename">CookieName</a></code>)、<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>中的指令(<code class="directive"><a href="../mod/mod_rewrite.html#rewriteengine">RewriteEngine</a></code>, <code class="directive"><a href="../mod/mod_rewrite.html#rewriteoptions">RewriteOptions</a></code>, <code class="directive"><a href="../mod/mod_rewrite.html#rewritebase">RewriteBase</a></code>, <code class="directive"><a href="../mod/mod_rewrite.html#rewritecond">RewriteCond</a></code>, <code class="directive"><a href="../mod/mod_rewrite.html#rewriterule">RewriteRule</a></code>)和<code class="module"><a href="../mod/mod_actions.html">mod_actions</a></code>中的<code class="directive"><a href="../mod/mod_actions.html#action">Action</a></code>指令。</dd>

      <dt>Indexes</dt>
      <dd>允许使用控制目录索引的指令(<code class="directive"><a href="../mod/mod_autoindex.html#adddescription">AddDescription</a></code>, <code class="directive"><a href="../mod/mod_autoindex.html#addicon">AddIcon</a></code>, <code class="directive"><a href="../mod/mod_autoindex.html#addiconbyencoding">AddIconByEncoding</a></code>, <code class="directive"><a href="../mod/mod_autoindex.html#addiconbytype">AddIconByType</a></code>, <code class="directive"><a href="../mod/mod_autoindex.html#defaulticon">DefaultIcon</a></code>, <code class="directive"><a href="../mod/mod_dir.html#directoryindex">DirectoryIndex</a></code>, <code class="directive"><a href="../mod/mod_autoindex.html#fancyindexing">FancyIndexing</a></code>, <code class="directive"><a href="../mod/mod_autoindex.html#headername">HeaderName</a></code>, <code class="directive"><a href="../mod/mod_autoindex.html#indexignore">IndexIgnore</a></code>, <code class="directive"><a href="../mod/mod_autoindex.html#indexoptions">IndexOptions</a></code>, <code class="directive"><a href="../mod/mod_autoindex.html#readmename">ReadmeName</a></code>, 等)。</dd>

      <dt>Limit</dt>
      <dd>允许使用控制主机访问的指令(<code class="directive"><a href="../mod/mod_authz_host.html#allow">Allow</a></code>, <code class="directive"><a href="../mod/mod_authz_host.html#deny">Deny</a></code>, <code class="directive"><a href="../mod/mod_authz_host.html#order">Order</a></code>)。</dd>

      <dt>Options[=<var>Option</var>,...]</dt>
      <dd>允许使用控制指定目录功能的指令(<code class="directive"><a href="#options">Options</a></code>和<code class="directive"><a href="../mod/mod_include.html#xbithack">XBitHack</a></code>)。可以在等号后面附加一个逗号分隔的(无空格的)<code class="directive"><a href="#options">Options</a></code>选项列表，用来控制允许<code class="directive"><a href="#options">Options</a></code>指令使用哪些选项。</dd>
    </dl>

    <p>例如以下指令只允许在<code>.htaccess</code>中使用<code>AuthConfig</code>和<code>Indexes</code>组的指令：</p>

    <div class="example"><p><code>
      AllowOverride AuthConfig Indexes
    </code></p></div>

    <p>不在这两组中的指令将会导致服务器产生一个内部错误。</p>

	<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#accessfilename">AccessFileName</a></code></li>
<li><a href="../configuring.html">配置文件</a></li>
<li><a href="../howto/htaccess.html">.htaccess文件</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="AuthName" id="AuthName">AuthName</a> <a name="authname" id="authname">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用于HTTP认证的授权域</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>AuthName <var>auth-domain</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>此指令为目录的授权域设置名字。此域将发送给客户端以使用户了解应当发送哪个用户名和密码。<code class="directive">AuthName</code>指令带有一个参数。如果域的名字中包含空格，则必须用引号引起来。它必须与<code class="directive"><a href="#authtype">AuthType</a></code>和<code class="directive"><a href="#require">Require</a></code>指令以及诸如<code class="directive"><a href="../mod/mod_authn_file.html#authuserfile">AuthUserFile</a></code>和<code class="directive"><a href="../mod/mod_authz_groupfile.html#authgroupfile">AuthGroupFile</a></code>这样的指令一起工作。</p>

   	<p>例如：</p>

   <div class="example"><p><code>
     AuthName "Top Secret"
   </code></p></div>

    <p>提供给<code>AuthName</code>的字符串将出现在大多数浏览器提供的密码对话框中。</p>

<h3>参见</h3>
<ul>
<li><a href="../howto/auth.html">认证、授权、访问控制</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="AuthType" id="AuthType">AuthType</a> <a name="authtype" id="authtype">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用户认证类型</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>AuthType Basic|Digest</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>此指令选择了一个目录的用户认证类型。目前只实现了<code>Basic</code>(<code class="module"><a href="../mod/mod_auth_basic.html">mod_auth_basic</a></code>)和<code>Digest</code>(<code class="module"><a href="../mod/mod_auth_digest.html">mod_auth_digest</a></code>)。</p>

    <p>要实现认证，还必须同时与<code class="directive"><a href="#authname">AuthName</a></code>和<code class="directive"><a href="#require">Require</a></code>指令一起使用。另外，服务器还必须包含一个认证支持模块(比如<code class="module"><a href="../mod/mod_authn_file.html">mod_authn_file</a></code>)和一个授权支持模块(比如<code class="module"><a href="../mod/mod_authz_user.html">mod_authz_user</a></code>)。</p>

	<h3>参见</h3>
<ul>
<li><a href="../howto/auth.html">认证、授权、访问控制</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="CGIMapExtension" id="CGIMapExtension">CGIMapExtension</a> <a name="cgimapextension" id="cgimapextension">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>定位CGI脚本解释器</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>CGIMapExtension <var>cgi-path</var> <var>.extension</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>NetWare only</td></tr>
</table>
    <p>此指令用于定位Apache CGI脚本解释器。比如，"<code>CGIMapExtension sys:\foo.nlm .foo</code>"将把所有具有<code>.foo</code>后缀的CGI脚本文件传递给FOO解释器。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ContentDigest" id="ContentDigest">ContentDigest</a> <a name="contentdigest" id="contentdigest">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>允许生成<code>Content-MD5</code>应答头</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ContentDigest On|Off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ContentDigest Off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>Options</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>此指令遵照RFC1854和RFC2068协议的定义启用了<code>Content-MD5</code>应答头的生成。</p>

    <p>MD5是一种为不定长度的数据计算出一个"消息摘要"(有时也称为"指纹")的算法。并且保证数据中的任何变化都会反应在消息摘要的变化中。</p>

    <p><code>Content-MD5</code>头提供了一种端到端的针对整个消息体的信息完整性检查方法。代理或者客户端会检查此头以侦测在传输过程中，消息体是否产生了意外的改变。一个头的例子如下：</p>

    <div class="example"><p><code>
      Content-MD5: AuLb7Dp1rqtRtxz2m9kRpA==
    </code></p></div>

    <p>请注意，因为对每个请求都要进行消息摘要的运算(没有对其值进行缓存)，所以这会对您的服务器造成性能方面的影响。</p>

    <p><code>Content-MD5</code>仅为由<code class="module"><a href="../mod/core.html">Apache核心</a></code>伺服的文档进行发送，而对于由模块处理的文档则不予理会。比如说SSI文档、CGI脚本的输出、字节范围的应答都不包括这个头。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="DefaultType" id="DefaultType">DefaultType</a> <a name="defaulttype" id="defaulttype">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>在服务器无法由其他方法确定内容类型时，发送的默认MIME内容类型</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>DefaultType <var>MIME-type</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>DefaultType text/plain</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>有时会发生这样的事：服务器会被要求提供一个文档，而这个文档的类型无法由它的<a class="glossarylink" href="../glossary.html#mime-type" title="see glossary">MIME类型</a>映射所决定。</p>

    <p>服务器必须通知客户端其文档的内容类型。所以当一个未知类型出现时，将会使用<code>DefaultType</code> 。例如：</p>

    <div class="example"><p><code>
      DefaultType image/gif
    </code></p></div>

    <p>这样的配置对于里面有很多gif图片而有些在文件名中缺少<code>.gif</code>扩展名的目录非常合适。</p>

    <p>注意，与<code class="directive"><a href="#forcetype">ForceType</a></code>指令的不同之处在于：此指令仅提供了默认的mime类型。所有其它mime类型的定义，包括文件的扩展名，或其它可以标识媒体类型的方法都会覆盖此默认值。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="Directory" id="Directory">&lt;Directory&gt;</a> <a name="directory" id="directory">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>封装一组指令，使之仅对文件空间中的某个目录及其子目录生效</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;Directory <var>directory-path</var>&gt;
... &lt;/Directory&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">&lt;Directory&gt;</code>和<code>&lt;/Directory&gt;</code>用于封装一组指令，使之仅对某个目录及其子目录生效。任何可以在"directory"作用域中使用的指令都可以使用。<var>Directory-path</var>可以是一个目录的完整路径，或是包含了Unix shell匹配语法的通配符字符串。在通配符字符串中，"<code>?</code>"匹配任何单个的字符，"<code>*</code>"匹配任何字符序列。您也可以使用"<code>[]</code>"来确定字符范围。以上通配符都不能匹配"/"字符。所以<code>&lt;Directory  /*/public_html&gt;</code>将无法匹配<code>/home/user/public_html</code> ，但<code>&lt;Directory /home/*/public_html&gt;</code>能够正确匹配。比如说：</p>

    <div class="example"><p><code>
      &lt;Directory /usr/local/httpd/htdocs&gt;<br />
      <span class="indent">
        Options Indexes FollowSymLinks<br />
      </span>
      &lt;/Directory&gt;
    </code></p></div>

    <div class="note">
      <p>使用<var>directory-path</var>参数的时候要注意：它们必须与Apache用于访问文件的文件系统路径保持一致。赋予特定<code>&lt;Directory&gt;</code>的指令将无法对通过不同路径指向的同一个目录文件生效，比如说通过另外一个符号连接生成的路径。</p>
    </div>

    <p>扩展的<a class="glossarylink" href="../glossary.html#regex" title="see glossary">正则表达式</a>也可以通过附加一个"<code>~</code>"字符来使用。比如说：</p>

    <div class="example"><p><code>
      &lt;Directory ~ "^/www/(.+/)*[0-9]{3}"&gt;
    </code></p></div>

    <p>将匹配<code>/www/</code>下所有由3个数字组成的目录。</p>

    <p>如果有多个(非正则表达式)<code class="directive">&lt;Directory&gt;</code>配置段符合包含某文档的目录(或其父目录)，那么指令将以短目录优先的规则进行应用。并包含<a href="#accessfilename">.htaccess</a>文件中的指令。比如说在</p>

    <div class="example"><p><code>
      &lt;Directory /&gt;<br />
      <span class="indent">
        AllowOverride None<br />
      </span>
      &lt;/Directory&gt;<br />
      <br />
      &lt;Directory /home/&gt;<br />
      <span class="indent">
        AllowOverride FileInfo<br />
      </span>
      &lt;/Directory&gt;
    </code></p></div>

    <p>中，访问文档<code>/home/web/dir/doc.html</code>的步骤如下：</p>

    <ul>
      <li>应用指令<code>AllowOverride None</code>(禁用<code>.htaccess</code>文件)。</li>

      <li>应用指令<code>AllowOverride FileInfo</code>(针对<code>/home</code>目录)。</li>

      <li>按顺序应用所有<code>/home/.htaccess</code> 、<code>/home/web/.htaccess</code> 、<code>/home/web/dir/.htaccess</code>中的<code>FileInfo</code>组指令。</li>
    </ul>

    <p>正则表达式将在所有普通配置段之后予以考虑。所有的正则表达式将根据它们出现在配置文件中的顺序进行应用。比如说，以下配置：</p>

    <div class="example"><p><code>
      &lt;Directory ~ abc$&gt;<br />
      <span class="indent">
        # ......<br />
      </span>
      &lt;/Directory&gt;
    </code></p></div>

    <p>正则表达式配置段将在所有普通的<code class="directive">&lt;Directory&gt;</code>和<code>.htaccess</code>文件应用之后才予以考虑。所以正则表达式将匹配<code>/home/abc/public_html/abc</code>并予以应用。</p>

   <p><strong>请注意：Apache对<code>&lt;Directory /&gt;</code>的默认访问权限为"<code>Allow from All</code>"。这意味着Apache将伺服任何通过URL映射的文件。我们建议您将这个配置做如下屏蔽：</strong></p>

    <div class="example"><p><code>
      &lt;Directory /&gt;<br />
      <span class="indent">
        Order Deny,Allow<br />
        Deny from All<br />
      </span>
      &lt;/Directory&gt;
    </code></p></div>

    <p><strong>然后在您<em>想要</em>使之被访问的目录中覆盖此配置。参阅<a href="../misc/security_tips.html">安全提示</a>以获取更多详情。</strong></p>

    <p>一般来说<code class="directive">&lt;Directory&gt;</code>指令只会出现在<code>httpd.conf</code>文件中，但它们也可能出现在任何其它配置文件中。<code class="directive">&lt;Directory&gt;</code>指令不可被嵌套使用，也不能出现在<code class="directive"><a href="#limit">&lt;Limit&gt;</a></code>或<code class="directive"><a href="#limitexcept">&lt;LimitExcept&gt;</a></code>配置段中。</p>

<h3>参见</h3>
<ul>
<li><a href="../sections.html">&lt;Directory&gt;、&lt;Location&gt;、&lt;Files&gt;配置段是如何工作的</a>中包含了当接受一个请求时，这些不同的配置段是如何组合工作的相关解释。</li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="DirectoryMatch" id="DirectoryMatch">&lt;DirectoryMatch&gt;</a> <a name="directorymatch" id="directorymatch">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>封装一些指令并作用于文件系统中匹配正则表达式的所有目录及其子目录</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;DirectoryMatch <var>regex</var>&gt;
... &lt;/DirectoryMatch&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">&lt;DirectoryMatch&gt;</code>和<code>&lt;/DirectoryMatch&gt;</code>用于封装一组指令。与<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>类似，此指令将仅作用于指定名字的目录及其子目录。然而，它可以接受一个<a class="glossarylink" href="../glossary.html#regex" title="see glossary">正则表达式</a>作为参数。比如说：</p>

    <div class="example"><p><code>
      &lt;DirectoryMatch "^/www/(.+/)*[0-9]{3}"&gt;
    </code></p></div>

    <p>将匹配<code>/www/</code>下所有由3个数字组成的目录。</p>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>获取如何在普通的<code class="directive">&lt;Directory&gt;</code>中使用正则表达式的描述。</li>
<li><a href="../sections.html">&lt;Directory&gt;、&lt;Location&gt;、&lt;Files&gt;配置段是如何工作的</a>中包含了当接受一个请求时，这些不同的配置段是如何组合工作的相关解释。</li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="DocumentRoot" id="DocumentRoot">DocumentRoot</a> <a name="documentroot" id="documentroot">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>组成网络上可见的主文档树的根目录</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>DocumentRoot <var>directory-path</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>DocumentRoot /usr/local/apache2/htdocs</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>此指令设置了<code class="program"><a href="../programs/httpd.html">httpd</a></code>伺服的目录。在没有使用类似<code class="directive"><a href="../mod/mod_alias.html#alias">Alias</a></code>这样的指令的情况下，服务器会将请求中的URL附加到<code>DocumentRoot</code>后面以构成指向文档的路径。比如说：</p>

    <div class="example"><p><code>
      DocumentRoot /usr/web
    </code></p></div>

    <p>于是对<code>http://www.my.host.com/index.html</code>的访问就会指向<code>/usr/web/index.html</code> 。如果<var>directory-path</var>不是绝对路径，则被假定为是相对于<code class="directive"><a href="#serverroot">ServerRoot</a></code>的路径。</p>

    <p>指定<code class="directive">DocumentRoot</code>时不应包括最后的"/"。</p>

<h3>参见</h3>
<ul>
<li><a href="../urlmapping.html">从URL到文件系统的映射</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="EnableMMAP" id="EnableMMAP">EnableMMAP</a> <a name="enablemmap" id="enablemmap">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>在递送中使用内存映射(memory-mapping)来读取文件</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>EnableMMAP On|Off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>EnableMMAP On</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>此指令指示<code class="program"><a href="../programs/httpd.html">httpd</a></code>在递送中如果需要读取一个文件的内容，它是否可以使用内存映射。当处理一个需要访问文件中的数据的请求时，比如说当递送一个使用<code class="module"><a href="../mod/mod_include.html">mod_include</a></code>进行服务器端分析的文件时，如果操作系统支持，Apache将默认使用内存映射。</p>

    <p>这种内存映射有时会带来性能的提高，但在某些情况下，您可能会需要禁用内存映射以避免一些操作系统的问题：</p>

    <ul>
    <li>在一些多处理器的系统上，内存映射会减低一些<code class="program"><a href="../programs/httpd.html">httpd</a></code>的性能。</li>
    <li>在挂载了NFS的<code class="directive"><a href="#documentroot">DocumentRoot</a></code>上，若已经将一个文件进行了内存映射，则删除或截断这个文件会造成<code class="program"><a href="../programs/httpd.html">httpd</a></code>因为分段故障而崩溃。</li>
    </ul>

    <p>在可能遇到这些问题的服务器配置过程中，您应当使用下面的命令来禁用内存映射：</p>

    <div class="example"><p><code>
      EnableMMAP Off
    </code></p></div>

    <p>对于挂载了NFS的文件夹，可以单独指定禁用内存映射：</p>

    <div class="example"><p><code>
      &lt;Directory "/path-to-nfs-files"&gt;
      <span class="indent">
        EnableMMAP Off
      </span>
      &lt;/Directory&gt;
    </code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="EnableSendfile" id="EnableSendfile">EnableSendfile</a> <a name="enablesendfile" id="enablesendfile">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>使用操作系统内核的sendfile支持来将文件发送到客户端</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>EnableSendfile On|Off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>EnableSendfile On</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.0.44 及以后的版本中可用</td></tr>
</table>
    <p>这个指令控制<code class="program"><a href="../programs/httpd.html">httpd</a></code>是否可以使用操作系统内核的sendfile支持来将文件发送到客户端。默认情况下，当处理一个请求并不需要访问文件内部的数据时(比如发送一个静态的文件内容)，如果操作系统支持，Apache将使用sendfile将文件内容直接发送到客户端而并不读取文件。译者注：Linux2.4/2.6内核都支持。</p>

    <p>这个sendfile机制避免了分开的读和写操作以及缓冲区分配，但是在一些平台或者一些文件系统上，最好禁止这个特性来避免一些问题：</p>

    <ul>
    <li>一些平台可能会有编译系统检测不到的有缺陷的sendfile支持，特别是将在其他平台上使用交叉编译得到的二进制文件运行于当前对sendfile支持有缺陷的平台时。</li>
    <li>在Linux上启用IPv6时，使用sendfile将会触发某些网卡上的TCP校验和卸载bug。</li>
    <li>当Linux运行在Itanium处理器上的时候，sendfile可能无法处理大于2GB的文件。</li>
    <li>对于一个通过网络挂载了NFS文件系统的<code class="directive"><a href="#documentroot">DocumentRoot</a></code> (比如：NFS或SMB)，内核可能无法可靠的通过自己的缓冲区服务于网络文件。</li>
    </ul>

    <p>如果出现以上情况，你应当禁用sendfile ：</p>

    <div class="example"><p><code>
      EnableSendfile Off
    </code></p></div>

    <p>针对NFS或SMB，这个指令可以被针对目录的设置覆盖：</p>

    <div class="example"><p><code>
      &lt;Directory "/path-to-nfs-files"&gt;
      <span class="indent">
        EnableSendfile Off
      </span>
      &lt;/Directory&gt;
    </code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ErrorDocument" id="ErrorDocument">ErrorDocument</a> <a name="errordocument" id="errordocument">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>当遇到错误的时候服务器将给客户端什么样的应答</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ErrorDocument <var>error-code</var> <var>document</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>在Apache2.0中引用文字的语法发生了变化</td></tr>
</table>
    <p>当遇到问题或错误的时候，Apache能被配置为进行以下四种处理之一：</p>
    <ol>
      <li>输出一个简单生硬的错误代码信息</li>
      <li>输出一个经过定制的信息</li>
      <li>重定向到一个本地的<var>URL-path</var>来处理这个问题(错误)</li>
      <li>重定向到一个外部的<var>URL</var>来处理这个问题(错误)</li>
    </ol>

    <p>默认会采取第1种方法，而第2-4种方法可以使用<code class="directive">ErrorDocument</code>指令后面跟随一个HTTP应答代码和一个URL或信息来进行配置。Apache有时会额外提供一些信息来描述所发生的问题/错误。</p>

    <p>URL可以由一个斜杠(/)开头来指示一个本地URL(相对于<code class="directive"><a href="#documentroot">DocumentRoot</a></code>)，或是提供一个能被客户端解释的完整的URL。此外还能提供一个可以被浏览器显示的消息。比如：</p>

    <div class="example"><p><code>
      ErrorDocument 500 http://foo.example.com/cgi-bin/tester<br />
      ErrorDocument 404 /cgi-bin/bad_urls.pl<br />
      ErrorDocument 401 /subscription_info.html<br />
      ErrorDocument 403 "Sorry can't allow you access today"
    </code></p></div>

    <p>另外，特殊的"<code>default</code>"值可以被用来指定使用Apache内置的、简单的硬编码消息。当不需要这个定制特性的时候，可以用"<code>default</code>"恢复Apache内置的、简单的硬编码消息，否则将继承一个已有的<code class="directive">ErrorDocument</code> 。</p>

    <div class="example"><p><code>
      ErrorDocument 404 /cgi-bin/bad_urls.pl<br /><br />
      &lt;Directory /web/docs&gt;<br />
      <span class="indent">
        ErrorDocument 404 default<br />
      </span>
      &lt;/Directory&gt;
    </code></p></div>

    <p>请注意，如果您为<code class="directive">ErrorDocument</code>指定了一个外部的URL(比如说，任何在开头指示了类似"<code>http</code>"这样的访问方法的字符串)，Apache将会向客户端发送一个重定向指令来告诉它在哪里找到这个文档，哪怕这个文档最后还是在这个服务器上。这里面包含着一些暗示：最重要的就是客户端无法接收到原始的错误状态代码，取而代之的是一个重定向状态代码。这将会使一些用状态代码来判断一个URL是否有效的web机器人或其它客户端产生误解。另外，如果您在"<code>ErrorDocument 401</code>"中使用了外部URL，客户端将不会提示用户输入密码，因为它根本没收到这样一个401的状态代码。所以，<strong>如果您想使用"<code>ErrorDocument 401</code>"指令，就必须指向一个本地的文档</strong>。</p>

    <p>Microsoft Internet Explorer (MSIE)在服务器端产生的错误信息"很小"的时候会忽略它们而用自己"友好的"错误信息进行取代。这个大小的阈值根据错误类型而不同。但一般来说，如果您的错误信息的大小在512 byte以上，MSIE就会显示这些服务器端产生的错误文档而不会屏蔽它们。您可以在微软知识库的文章<a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;Q294807">Q294807</a>中获取更多信息。</p>

    <p>虽然大多数错误信息可以被改写，但是在有些情况下，将仍然使用某些内置的错误信息而不管<code class="directive"><a href="#errordocument">ErrorDocument</a></code>如何设置。特别是在检测到一个"畸形"请求的情况下，正常的请求处理过程将会被立即中断，并且立即返回一个内置的错误信息。这是为了防止某些不良请求可能导致的安全问题。</p>

    <p>在2.0版以前，信息前面会用一个不配对的双引号作为前导标志。</p>

<h3>参见</h3>
<ul>
<li><a href="../custom-error.html">定制个性化应答文档</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ErrorLog" id="ErrorLog">ErrorLog</a> <a name="errorlog" id="errorlog">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>存放错误日志的位置</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code> ErrorLog <var>file-path</var>|syslog[:<var>facility</var>]</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ErrorLog logs/error_log (Unix) ErrorLog logs/error.log (Windows 和 OS/2)</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">ErrorLog</code>指令指定了当服务器遇到错误时记录错误日志的文件。如果<var>file-path</var>不是一个以斜杠(/)开头的绝对路径，那么将被认为是一个相对于<code class="directive"><a href="#serverroot">ServerRoot</a></code>的相对路径。</p>

    <div class="example"><h3>示例</h3><p><code>
    ErrorLog /var/log/httpd/error_log
    </code></p></div>

    <p>如果<var>file-path</var>以一个管道符号(|)开头，那么会为它指定一个命令来处理错误日志。</p>

    <div class="example"><h3>示例</h3><p><code>
    ErrorLog "|/usr/local/bin/httpd_errors"
    </code></p></div>

    <p>如果系统支持，使用"<code>syslog</code>"替代文件名将通过syslogd(8)来记载日志。默认将使用系统日志机制<code>local7</code> ，但您可以用"<code>syslog:<var>facility</var></code>"语法来覆盖这个设置，其中，<var>facility</var>的取值为syslog(1)中记载的任何一个名字。</p>

    <div class="example"><h3>示例</h3><p><code>
    ErrorLog syslog:user
    </code></p></div>

    <p><em>安全提示</em>：参阅<a href="../misc/security_tips.html#serverroot">安全提示</a>文档获得关于为什么当记录日志文件的目录对于启动服务器以外的用户可写时会对您的服务器构成安全威胁。</p>
    <div class="warning"><h3>注意</h3>
      <p>当在非Unix平台上输入文件路径的时候，路径分隔符必须统一使用正斜线(/)，即使那个平台本身使用反斜线(\)。</p>
    </div>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#loglevel">LogLevel</a></code></li>
<li><a href="../logs.html">Apache日志文件</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="FileETag" id="FileETag">FileETag</a> <a name="fileetag" id="fileetag">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>用以创建ETag应答头的文件的属性</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>FileETag <var>component</var> ...</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>FileETag INode MTime Size</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">FileETag</code>指令配置了当文档是基于一个文件时用以创建<code>ETag</code>(实体标签)应答头的文件的属性(<code>ETag</code>的值用于进行缓冲管理以节约网络带宽)。在Apache1.3.22及以前，<code>ETag</code>的值<em>总是</em>由文件的inode(索引节点)、大小、最后修改时间决定。<code class="directive">FileETag</code>指令可以让您选择(如果您想进行选择)这其中哪些要素将被使用。主要关键字如下：</p>

    <dl>
     <dt><strong>INode</strong></dt>
     <dd>文件的索引节点(inode)数</dd>
     <dt><strong>MTime</strong></dt>
     <dd>文件的最后修改日期及时间</dd>
     <dt><strong>Size</strong></dt>
     <dd>文件的字节数</dd>
     <dt><strong>All</strong></dt>
     <dd>所有存在的域，等价于：<div class="example"><p><code>FileETag INode MTime Size</code></p></div></dd>
     <dt><strong>None</strong></dt>
     <dd>如果一个文档是基于文件的，则不在应答中包含任何<code>ETag</code>头</dd>
    </dl>

    <p>可以在<code>INode</code>, <code>MTime</code>, <code>Size</code>前加上"<code>+</code>"或"<code>-</code>"以改变由上层继承下来的默认值。任何没有上述前缀的关键字将立刻完全取消继承下来的设置。</p>

    <p>如果一个目录的配置包含了"<code>FileETag INode MTime Size</code>"而其一个子目录包含了"<code>FileETag -INode</code>"那么这个子目录的设置(并会被其下任何没有进行覆盖的子目录继承)将等价于"<code>FileETag MTime Size</code>"。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="Files" id="Files">&lt;Files&gt;</a> <a name="files" id="files">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>包含作用于匹配指定文件名的指令</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;Files <var>filename</var>&gt; ... &lt;/Files&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">&lt;Files&gt;</code>指令提供了基于文件名的访问控制，类似于<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>和<code class="directive"><a href="#location">&lt;Location&gt;</a></code>指令。它将配对一个<code>&lt;/Files&gt;</code>指令。在此配置段中定义的指令将作用于其基本名称(不是完整的路径)与指定的文件名相符的对象。<code class="directive">&lt;Files&gt;</code>段将根据它们在配置文件中出现的顺序被处理：在<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>段和<code>.htaccess</code>文件被处理之后，但在<code class="directive"><a href="#location">&lt;Location&gt;</a></code>段之前。请注意：<code class="directive">&lt;Files&gt;</code>能嵌入到<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>段中以限制它们作用的文件系统范围。</p>

    <p><var>filename</var>参数应当是一个文件名或是一个包含通配符的字符串，其中"<code>?</code>"匹配任何单个字符，"<code>*</code>"匹配任何字符串序列。在"<code>~</code>"字符之后同样可以使用<a class="glossarylink" href="../glossary.html#regex" title="see glossary">正则表达式</a>。比如：</p>

    <div class="example"><p><code>
      &lt;Files ~ "\.(gif|jpe?g|png)$"&gt;
    </code></p></div>

    <p>将匹配绝大部分常见的因特网图象格式。然而在Apache1.3及其后继版本中，更推荐使用<code class="directive"><a href="#filesmatch">&lt;FilesMatch&gt;</a></code>指令。</p>

    <p>请注意与<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>和<code class="directive"><a href="#location">&lt;Location&gt;</a></code>配置段不同的是：<code class="directive">&lt;Files&gt;</code>配置段可用于<code>.htaccess</code>文件当中。这将允许用户在文件层面上控制对它们自己文件的访问。</p>


<h3>参见</h3>
<ul>
<li><a href="../sections.html">&lt;Directory&gt;、&lt;Location&gt;、&lt;Files&gt;配置段是如何工作的</a>中包含了当接受一个请求时，这些不同的配置段是如何组合工作的相关解释。</li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="FilesMatch" id="FilesMatch">&lt;FilesMatch&gt;</a> <a name="filesmatch" id="filesmatch">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>包含作用于与正则表达式匹配的文件名的指令</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;FilesMatch <var>regex</var>&gt; ... &lt;/FilesMatch&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">&lt;FilesMatch&gt;</code>指令就像<code class="directive"><a href="#files">&lt;Files&gt;</a></code>指令一样提供了针对文件名的访问控制。然而，它使用的是<a class="glossarylink" href="../glossary.html#regex" title="see glossary">正则表达式</a>。比如说：</p>

    <div class="example"><p><code>
      &lt;FilesMatch "\.(gif|jpe?g|png)$"&gt;
    </code></p></div>

    <p>将匹配最常见的internet图形文件格式。</p>

<h3>参见</h3>
<ul>
<li><a href="../sections.html">&lt;Directory&gt;、&lt;Location&gt;、&lt;Files&gt;配置段是如何工作的</a>中包含了当接受一个请求时，这些不同的配置段是如何组合工作的相关解释。</li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ForceType" id="ForceType">ForceType</a> <a name="forcetype" id="forcetype">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>强制所有匹配的文件被作为指定的MIME类型进行伺服</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ForceType <var>MIME-type</var>|None</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>Apache 2.0之后从其它模块移动到核心中</td></tr>
</table>
    <p>当此指令放入<code>.htaccess</code>文件或<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>或<code class="directive"><a href="#location">&lt;Location&gt;</a></code>或<code class="directive"><a href="#files">&lt;Files&gt;</a></code>配置段时，此指令强制所有匹配的文件被当作在<var>MIME-type</var>中指定的Content-Type来伺服。比如说，如果您有一个包含大量GIF文件的目录，可您又不想全都为它们加上"<code>.gif</code>"扩展名的话，您可以这样做：</p>

    <div class="example"><p><code>
      ForceType image/gif
    </code></p></div>

    <p>请注意：与<code class="directive"><a href="#defaulttype">DefaultType</a></code>指令不同，此指令将覆盖所有的mime类型关联，包括标识文件类型的扩展名。</p>

    <p>你可以通过使用"<code>None</code>"覆盖任何<code class="directive">ForceType</code>设置：</p>

    <div class="example"><p><code>
      #  强制所有文件为 image/gif:<br />
      &lt;Location /images&gt;<br />
        <span class="indent">
          ForceType image/gif<br />
        </span>
      &lt;/Location&gt;<br />
      <br />
      # 但是正常的mime类型关联在这里:<br />
      &lt;Location /images/mixed&gt;<br />
      <span class="indent">
        ForceType None<br />
      </span>
      &lt;/Location&gt;
    </code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="HostnameLookups" id="HostnameLookups">HostnameLookups</a> <a name="hostnamelookups" id="hostnamelookups">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>启用对客户端IP的DNS查找</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>HostnameLookups On|Off|Double</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>HostnameLookups Off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>此指令启用了DNS查询，使得主机名能被记入日志(并用<code>REMOTE_HOST</code>变量传递给CGI/SSI)。参数<code>Double</code>指定进行一次双向DNS查询。也就是说在一次反向查询之后，再对返回的结果进行一次正向查询。在正向查询结果中至少应该有一个ip地址与初始的地址相符。(在"tcpwrappers"中的术语是<code>PARANOID</code>)</p>

    <p>不论此处如何设置，当您使用<code class="module"><a href="../mod/mod_authz_host.html">mod_authz_host</a></code>来根据主机名控制访问的时候，就会执行一次双向查询。这对安全来说非常必要。请注意如果您没有设置"<code>HostnameLookups Double</code>"，这种双向查询的结果不是自动生成的。比如说：如果仅仅设置了"<code>HostnameLookups On</code>"而且请求是针对一个根据主机名做了限制的对象，不论双向查询是否失败，CGI还是会把单向查询的结果用<code>REMOTE_HOST</code>来传送。</p>

    <p>默认值设置为 <code>Off</code> 是为了那些不需要进行反向查询的站点节约网络带宽考虑的。这对最终用户也是有益的，因为这样他们就不用忍受查询造成的延迟了。高访问量的网站应该将此指令设置为 <code>Off</code> 因为DNS查询会造成明显的时间消耗。在<code>bin</code>目录下的<code class="program"><a href="../programs/logresolve.html">logresolve</a></code>工具可以在离线的情况下对已经记入日志的IP地址进行主机名的查询。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="IfDefine" id="IfDefine">&lt;IfDefine&gt;</a> <a name="ifdefine" id="ifdefine">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>封装一组只有在启动时当测试结果为真时才生效的指令</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;IfDefine [!]<var>parameter-name</var>&gt; ...
    &lt;/IfDefine&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code>&lt;IfDefine <var>test</var>&gt;...&lt;/IfDefine&gt;</code>配置段用于包含有条件的指令。<code class="directive">&lt;IfDefine&gt;</code>配置段中的指令仅当<var>test</var>结果为真时才进行处理。如果<var>test</var>为假。此配置段中的指令将会被忽略。</p>

    <p><code class="directive">&lt;IfDefine&gt;</code>配置段中的<var>test</var>可以为以下两种形式之一：</p>

    <ul>
      <li><var>parameter-name</var></li>

      <li><code>!</code><var>parameter-name</var></li>
    </ul>

    <p>在第一种情况下，仅当<var>parameter-name</var>已经定义的情况下才对开始和结束标记之间的指令进行处理。第二种情况则截然相反。仅当<var>parameter-name</var><strong>没有</strong>定义的情况下才进行指令的处理。</p>

    <p><var>parameter-name</var>是在服务启动时，通过<code class="program"><a href="../programs/httpd.html">httpd</a></code>命令行的 <code>-D<var>parameter</var></code> 这样的形式指定的。</p>

    <p><code class="directive">&lt;IfDefine&gt;</code>配置段是可以嵌套的，从而可以实现简单的多参数测试。比如说：</p>

    <div class="example"><p><code>
      httpd -DReverseProxy ...<br />
      <br />
      # httpd.conf<br />
      &lt;IfDefine ReverseProxy&gt;<br />
      <span class="indent">
        LoadModule rewrite_module modules/mod_rewrite.so<br />
        LoadModule proxy_module   modules/libproxy.so<br />
      </span>
      &lt;/IfDefine&gt;
    </code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="IfModule" id="IfModule">&lt;IfModule&gt;</a> <a name="ifmodule" id="ifmodule">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>封装指令并根据指定的模块是否启用为条件而决定是否进行处理</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;IfModule [!]<var>module-file</var>|<var>module-identifier</var>&gt; ... &lt;/IfModule&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td><var>module-identifier</var>仅在 Apache 2.1 及以后的版本中可用</td></tr>
</table>
    <p><code>&lt;IfModule <var>test</var>&gt;...&lt;/IfModule&gt;</code>配置段用于封装根据指定的模块是否启用而决定是否生效的指令。在<code class="directive">&lt;IfModule&gt;</code>配置段中的指令仅当<var>test</var>为真的时候才进行处理。如果<var>test</var>为假，所有其间的指令都将被忽略。</p>

    <p><code class="directive">&lt;IfModule&gt;</code>段中的<var>test</var>可以为以下两种方式之一：</p>

    <ul>
      <li><var>module</var></li>

      <li>!<var>module</var></li>
    </ul>

    <p>在第一种情况下，起始和结束标记之间的指令仅当<var>module</var>被载入后才被执行。此模块可以为编译时静态链接进核心的模块或是使用<code class="directive"><a href="../mod/mod_so.html#loadmodule">LoadModule</a></code>指令动态载入的模块。第二种情况则相反，仅当<var>module</var><strong>没有</strong>载入时才进行指令的处理。</p>

    <p><var>module</var>可以是模块的标识符或者是编译模块时的文件名。比如，<code>rewrite_module</code>就是一个模块标识符，而<code>mod_rewrite.c</code>则是编译模块时的文件名。如果模块包含多个源代码文件，您应当使用包含<code>STANDARD20_MODULE_STUFF</code>字符串的那个。</p>

    <p><code class="directive">&lt;IfModule&gt;</code>配置段是可以嵌套的，从而可以实现简单的多模块测试。</p>

    <div class="note">此配置段主要用于需要根据某个特定的模块是否存在来决定是否使用某些配置的时候。指令一般都放在<code class="directive">&lt;IfModule&gt;</code>配置段中。</div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="Include" id="Include">Include</a> <a name="include" id="include">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>在服务器配置文件中包含其它配置文件</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>Include <var>file-path</var>|<var>directory-path</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>通配符仅在 Apache 2.0.41 及以后的版本中可用</td></tr>
</table>
    <p>这个指令允许在服务器配置文件中加入其它配置文件。</p>

    <p>Shell风格(<code>fnmatch()</code>)的通配符可以用于按照字母顺序一次包含多个文件。另外，如果<code class="directive">Include</code>指向了一个目录而不是一个文件，Apache将读入该目录及其子目录下的所有文件，并依照字母顺序将这些文件作为配置文件进行解析。但是并不推荐这么做，因为偶尔会有临时文件在这个目录中生成，从而导致<code class="program"><a href="../programs/httpd.html">httpd</a></code>启动失败。</p>

    <p>文件的路径可以是一个完整的绝对路径(以一个斜杠开头)：</p>
    <div class="example"><p><code>
      Include /usr/local/apache2/conf/ssl.conf<br />
      Include /usr/local/apache2/conf/vhosts/*.conf
    </code></p></div>

    <p>或是相对于<code class="directive"><a href="#serverroot">ServerRoot</a></code>目录的相对路径：</p>
    <div class="example"><p><code>
      Include conf/ssl.conf<br />
      Include conf/vhosts/*.conf
    </code></p></div>

    <p>请确保包含的目录中不包含任何诸如编辑器临时文件等引起误导的文件，因为Apache会尝试读取它们并把其中的内容作为配置指令来处理，这样可能会导致启动过程的失败。运行 <code>apachectl configtest</code> 将会把配置检查时所使用的所有文件列出来以供参考。这将有助于检验配置中是否仅包含了您所希望出现那些文件。</p>

    <div class="example"><p><code>
      root@host# apachectl configtest<br />
      Processing config file: /usr/local/apache2/conf/ssl.conf<br />
      Processing config file: /usr/local/apache2/conf/vhosts/vhost1.conf<br />
      Processing config file: /usr/local/apache2/conf/vhosts/vhost2.conf<br />
      Syntax OK
    </code></p></div>

<h3>参见</h3>
<ul>
<li><code class="program"><a href="../programs/apachectl.html">apachectl</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="KeepAlive" id="KeepAlive">KeepAlive</a> <a name="keepalive" id="keepalive">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>启用HTTP持久链接</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>KeepAlive On|Off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>KeepAlive On</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>Keep-Alive扩展自HTTP/1.0和HTTP/1.1的持久链接特性。提供了长效的HTTP会话，用以在同一个TCP连接中进行多次请求。在某些情况下，这样的方式会对包含大量图片的HTML文档造成的延时起到50%的加速作用。在Apache1.2版本以后，您可以设置 <code>KeepAlive On</code> 以启用持久链接。</p>

    <p>对于HTTP/1.0的客户端来说，仅当客户端指定使用的时候才会使用持久链接连接。此外，仅当能够预先知道传输的内容长度时，才会与HTTP/1.0的客户端建立持久链接连接。这意味着那些长度不定的内容，诸如CGI输出、SSI页面、以及服务器端生成的目录列表等内容一般来说将无法使用与HTTP/1.0客户端建立的持久链接连接。而对于HTTP/1.1的客户端来说，如果没有进行特殊指定，持久将是默认的连接方式。如果客户端进行了请求，将使用分块编码以解决在持久链接里发送未知长度内容的问题。</p>

	<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#maxkeepaliverequests">MaxKeepAliveRequests</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="KeepAliveTimeout" id="KeepAliveTimeout">KeepAliveTimeout</a> <a name="keepalivetimeout" id="keepalivetimeout">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>持久链接中服务器在两次请求之间等待的秒数</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>KeepAliveTimeout <var>seconds</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>KeepAliveTimeout 5</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>Apache在关闭持久连接前等待下一个请求的秒数。一旦收到一个请求，超时值将会被设置为<code class="directive"><a href="#timeout">Timeout</a></code>指令指定的秒数。</p>

    <p>对于高负荷服务器来说，<code class="directive">KeepAliveTimeout</code>值较大会导致一些性能方面的问题：超时值越大，与空闲客户端保持连接的进程就越多。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="Limit" id="Limit">&lt;Limit&gt;</a> <a name="limit" id="limit">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>仅对指定的HTTP方法进行访问控制</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;Limit <var>method</var> [<var>method</var>] ... &gt; ... &lt;/Limit&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>访问控制一般来说是对<strong>所有</strong>的访问方法都生效的，这也是我们普遍希望达到的效果。一般情况下，<strong>访问控制指令不应该放入<code class="directive">&lt;Limit&gt;</code>段中</strong>。</p>

    <p><code class="directive">&lt;Limit&gt;</code>指令的目的是限制访问控制的效果使其仅作用于某些HTTP方法。对于其它方法，<code class="directive">&lt;Limit&gt;</code>括号中的访问限制将<strong>不起任何作用</strong>。下例中的访问控制仅作用于<code>POST</code>, <code>PUT</code>, <code>DELETE</code>方法，其它方法不受任何影响：</p>

    <div class="example"><p><code>
      &lt;Limit POST PUT DELETE&gt;<br />
      <span class="indent">
        Require valid-user<br />
      </span>
      &lt;/Limit&gt;
    </code></p></div>

    <p>列出的方法名可为下列的一个或多个：<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>CONNECT</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>PROPFIND</code>, <code>PROPPATCH</code>, <code>MKCOL</code>, <code>COPY</code>, <code>MOVE</code>, <code>LOCK</code>, <code>UNLOCK</code> 。<strong>方法名是大小写敏感的</strong>。如果对<code>GET</code>进行了定义，它会同时作用于<code>HEAD</code>请求。<code>TRACE</code>方法不能被限制。</p>

    <div class="warning">应当总是优先使用<code class="directive"><a href="#limitexcept">&lt;LimitExcept&gt;</a></code>段来限制访问，而不是<code class="directive"><a href="#limit">&lt;Limit&gt;</a></code>段。因为<code class="directive"><a href="#limitexcept">&lt;LimitExcept&gt;</a></code>段能够防范所有HTTP方法。</div>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="LimitExcept" id="LimitExcept">&lt;LimitExcept&gt;</a> <a name="limitexcept" id="limitexcept">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>对除了指定方法以外的所有HTTP方法进行访问控制</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;LimitExcept <var>method</var> [<var>method</var>] ... &gt; ... &lt;/LimitExcept&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">&lt;LimitExcept&gt;</code>和<code>&lt;/LimitExcept&gt;</code>用于封装一组访问控制指令，并将其作用于所有<strong>没有</strong>在参数中标出的HTTP方法。也就是说，与<code class="directive"><a href="#limit">&lt;Limit&gt;</a></code>相反，它用于控制标准的和非标准以及无法辨识的方法。</p>

    <p>比如：</p>

    <div class="example"><p><code>
      &lt;LimitExcept POST GET&gt;<br />
      <span class="indent">
        Require valid-user<br />
      </span>
      &lt;/LimitExcept&gt;
    </code></p></div>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="LimitInternalRecursion" id="LimitInternalRecursion">LimitInternalRecursion</a> <a name="limitinternalrecursion" id="limitinternalrecursion">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>指定内部重定向和嵌套子请求的最大数量</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>LimitInternalRecursion <var>number</var> [<var>number</var>]</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>LimitInternalRecursion 10</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.0.47 及以后的版本中可用</td></tr>
</table>
    <p>例如，当使用<code class="directive"><a href="../mod/mod_actions.html#action">Action</a></code>指令内部重定向原始请求到一个CGI脚本时，一个内部重定向将会发生。子请求是Apache的一个用于找到如果一个URI被请求时将会发生什么的机制。例如，<code class="module"><a href="../mod/mod_dir.html">mod_dir</a></code>使用子请求来寻找那些根据<code class="directive"><a href="../mod/mod_dir.html#directoryindex">DirectoryIndex</a></code>指令应当被列出的文件。</p>

    <p><code class="directive">LimitInternalRecursion</code>可以防止服务器进入一个内部重定向或者子请求的死循环而崩溃。这样的死循环通常由错误的配置引起。</p>

    <p>这个指令存储了两个不同的限制，这两个限制是基于每个单独的请求进行计算的。第一个<var>number</var>限制了内部重定向链的最大长度(一个接一个)。第二个<var>number</var>限制了子请求的最大嵌套层数。如果你只指定了一个<var>number</var> ，那么将会被同时应用于这两个限制。</p>

    <div class="example"><h3>示例</h3><p><code>
      LimitInternalRecursion 5
    </code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="LimitRequestBody" id="LimitRequestBody">LimitRequestBody</a> <a name="limitrequestbody" id="limitrequestbody">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>限制客户端发送的HTTP请求体的最大字节长度</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>LimitRequestBody <var>bytes</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>LimitRequestBody 0</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><var>bytes</var>在0(意味着无限制)到2147483647(2GB)间限制了请求体所允许的字节数。</p>

    <p><code class="directive">LimitRequestBody</code>可以让用户在其作用范围内(整个服务器、特定目录、特定文件、特定位置)设置一个允许客户端发送的HTTP请求体的最大字节长度的限制。如果客户端的请求超出了这个限制，服务器会回应一个错误而不是伺服这个请求。一个普通请求的信息体在很大程度上取决于资源的自然属性和这个资源允许的方法。CGI脚本经常用消息体把表单的信息传递给服务器。使用<code>PUT</code>方法至少会需要与服务器期望从这个资源得到的信息量差不多大小的值。</p>

    <p>此指令给了服务器管理员更大的可控性以控制客户端不正常的请求行为。这有助于避免某些形式的拒绝服务攻击。</p>

    <p>比如，如果您允许文件上传到某个位置，而且希望能将上传文件的大小设置为100K，您可以使用下面的指令：</p>

    <div class="example"><p><code>
      LimitRequestBody 102400
    </code></p></div>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="LimitRequestFields" id="LimitRequestFields">LimitRequestFields</a> <a name="limitrequestfields" id="limitrequestfields">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>限制接受客户端请求中HTTP请求头域的数量</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>LimitRequestFields <var>number</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>LimitRequestFields 100</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><var>Number</var>是一个0(意味着不限)到32767之间的整数。默认值为编译时的常量<code>DEFAULT_LIMIT_REQUEST_FIELDS</code>(发布值为100)。</p>

    <p><code class="directive">LimitRequestFields</code>指令允许服务器管理员修改在一个HTTP请求中的请求头域的数量限制。服务器需要此值大于一个普通客户端请求中包含头域的数量。一个客户端请求头域的数量很少大于20，但根据客户端的不同这个数字有很大的差别，经常取决于用户配置他们的浏览器扩展以支持更详细的内容协商。可选的HTTP扩展经常使用请求头域来实现。</p>

    <p>这个指令给了服务器管理员更大的可控性以控制客户端不正常的请求行为。这有助于避免某些形式的拒绝服务攻击。如果正常使用的客户端得到了服务器的错误应答，指出其在请求中发送了过多的头域，您应该适当的增大此值。</p>

    <p>例如：</p>

    <div class="example"><p><code>
      LimitRequestFields 50
    </code></p></div>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="LimitRequestFieldSize" id="LimitRequestFieldSize">LimitRequestFieldSize</a> <a name="limitrequestfieldsize" id="limitrequestfieldsize">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>限制客户端发送的请求头的字节数</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>LimitRequestFieldsize <var>bytes</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>LimitRequestFieldsize 8190</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><var>bytes</var>指定了HTTP请求头允许的字节大小。</p>

    <p><code class="directive">LimitRequestFieldSize</code>指令允许服务器管理员增加或减少HTTP请求头域大小的限制。一般来说，服务器需要此值足够大，以适应普通客户端的任何请求的头域大小。一个普通头域的大小对于不同的客户端来说是有很大差别的，一般与用户配置他们的浏览器以支持更多的内容协议密切相关。SPNEGO的认证头最大可能达到12392字节。</p>

    <p>这个指令给了服务器管理员更大的可控性以控制客户端不正常的请求行为。这有助于避免某些形式的拒绝服务攻击。</p>

    <p>举例如下：</p>

    <div class="example"><p><code>
      LimitRequestFieldSize 4094
    </code></p></div>

    <div class="note">一般情况下，请不要改变这个设置，而是保持其默认设置。</div>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="LimitRequestLine" id="LimitRequestLine">LimitRequestLine</a> <a name="limitrequestline" id="limitrequestline">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>限制接受客户端发送的HTTP请求行的字节数</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>LimitRequestLine <var>bytes</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>LimitRequestLine 8190</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><var>bytes</var>将设置HTTP请求行的字节数限制。</p>

    <p><code class="directive">LimitRequestLine</code>指令允许服务器管理员增加或减少客户端HTTP请求行允许大小的限制。因为请求行包括HTTP方法、URI、协议版本，所以<code class="directive">LimitRequestLine</code>指令会限制请求URI的长度。服务器会需要这个值足够大以装载它所有的资源名，包括可能在<code>GET</code>请求中所传递的查询部分的所有信息。</p>

    <p>这个指令给了服务器管理员更大的可控性以控制客户端不正常的请求行为。这有助于避免某些形式的拒绝服务攻击。</p>

    <p>举例如下：</p>

    <div class="example"><p><code>
      LimitRequestLine 4094
    </code></p></div>

    <div class="note">一般情况下，不需要改变此设置的默认值。</div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="LimitXMLRequestBody" id="LimitXMLRequestBody">LimitXMLRequestBody</a> <a name="limitxmlrequestbody" id="limitxmlrequestbody">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>限制基于XML的请求体的大小</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>LimitXMLRequestBody <var>bytes</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>LimitXMLRequestBody 1000000</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>限制基于XML的请求体大小的最大字节数，"<code>0</code>"将禁用这一检查。</p>

    <p>比如：</p>

    <div class="example"><p><code>
      LimitXMLRequestBody 0
    </code></p></div>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="Location" id="Location">&lt;Location&gt;</a> <a name="location" id="location">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>将封装的指令作用于匹配的URL</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;Location
    <var>URL-path</var>|<var>URL</var>&gt; ... &lt;/Location&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">&lt;Location&gt;</code>提供了基于URL的访问控制。与<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>指令类似，它也会启用一个以<code>&lt;/Location&gt;</code>结尾的配置段。<code class="directive">&lt;Location&gt;</code>配置段的处理位于<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>, <code>.htaccess</code>, <code class="directive"><a href="#files">&lt;Files&gt;</a></code>之后，并依照在配置文件中出现的顺序进行处理。</p>

    <p><code class="directive">&lt;Location&gt;</code>配置段完全独立于文件系统之外操作。这有几个重要的后果。最重要的是<code class="directive">&lt;Location&gt;</code>不能用于针对文件系统的访问控制。因为可能会有几个不同的URL指向文件系统中的同一个文件，所以这样的控制常常会被很容易的绕过。</p>

    <div class="note"><h3>何时使用<code class="directive">&lt;Location&gt;</code>？</h3>

    <p>使用<code class="directive">&lt;Location&gt;</code>来将指令应用于独立于文件系统之外的内容。文件系统之内的内容请使用<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>和<code class="directive"><a href="#files">&lt;Files&gt;</a></code>指令。不过一个例外是<code>&lt;Location /&gt;</code> ，它可以方便的作用于所用URL。</p>
    </div>

    <p>对所有的原始(非代理)请求来说，匹配的URL应该是具有"<code>/path/</code>"形式的URL路径。不包括访问方法、主机名、端口或查询字符串等。对于代理的请求，匹配的URL必须为"<code>scheme://servername/path</code>"的形式，而且必须包括前缀。</p>

    <p>URL可以用一个通配符字符串来进行通配符的处理。"<code>?</code>"匹配任何单个的字符，而"<code>*</code>"匹配所有字符序列。</p>

    <p>也可以附加"<code>~</code>"字符来表示使用<a class="glossarylink" href="../glossary.html#regex" title="see glossary">正则表达式</a>。例如：</p>

    <div class="example"><p><code>
      &lt;Location ~ "/(extra|special)/data"&gt;
    </code></p></div>

    <p>将匹配所有包含字符串"<code>/extra/data</code>"或"<code>/special/data</code>"的URL。在Apache1.3及其后续版本中，加入了一个新的推荐使用的<code class="directive"><a href="#locationmatch">&lt;LocationMatch&gt;</a></code>指令，其功能与<code class="directive">&lt;Location&gt;</code>的正则表达式版本相同。</p>

    <p><code class="directive">&lt;Location&gt;</code>的功能在与<code class="directive"><a href="#sethandler">SetHandler</a></code>指令联用时能发挥最大效能。比如启用状态请求，但仅对来自<code>foo.com</code>的用户起效，您可以这样使用：</p>

    <div class="example"><p><code>
      &lt;Location /status&gt;<br />
      <span class="indent">
        SetHandler server-status<br />
        Order Deny,Allow<br />
        Deny from all<br />
        Allow from .foo.com<br />
      </span>
      &lt;/Location&gt;
    </code></p></div>

    <div class="note"><h3>请注意"/"(斜线)</h3>
      <p>斜线字符根据它在URL中出现的位置不同有着特殊的意义。大家可能都已经习惯在文件系统中，多个连续的斜线会被作为单一的斜线处理(例如"<code>/home///foo</code>"与"<code>/home/foo</code>"相同)。但在URL里面，这样是行不通的。<code class="directive"><a href="#locationmatch">&lt;LocationMatch&gt;</a></code>指令和正则表达式版本的<code class="directive">&lt;Location&gt;</code>要求您明确使用多重斜线。比如：<code>&lt;LocationMatch ^/abc&gt;</code>将匹配请求"<code>/abc</code>"但不会匹配请求"<code>//abc</code>"。而非正则表达式版本的<code class="directive">&lt;Location&gt;</code>指令在用于代理请求时，也有类似表现。但当非正则表达式版本的<code class="directive">&lt;Location&gt;</code>作用于非代理请求时，它会将多个毗邻的斜线认作单个斜线。比如，如果您指定了<code>&lt;Location /abc/def&gt;</code>而请求是指向"<code>/abc//def</code>"的，那么它们就是匹配的。</p>
    </div>

<h3>参见</h3>
<ul>
<li><a href="../sections.html">&lt;Directory&gt;、&lt;Location&gt;、&lt;Files&gt;配置段是如何工作的</a>中包含了当接受一个请求时，这些不同的配置段是如何组合工作的相关解释。</li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="LocationMatch" id="LocationMatch">&lt;LocationMatch&gt;</a> <a name="locationmatch" id="locationmatch">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>将封装的指令作用于正则表达式匹配的URL</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;LocationMatch
    <var>regex</var>&gt; ... &lt;/LocationMatch&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">&lt;LocationMatch&gt;</code>和<code class="directive"><a href="#location">&lt;Location&gt;</a></code>指令相同，提供了基于URL的访问控制。但它使用<a class="glossarylink" href="../glossary.html#regex" title="see glossary">正则表达式</a>作为参数，而不是简单字符串。比如：</p>

    <div class="example"><p><code>
      &lt;LocationMatch "/(extra|special)/data"&gt;
    </code></p></div>

    <p>将匹配包含子串"<code>/extra/data</code>"或"<code>/special/data</code>"的URL。</p>

<h3>参见</h3>
<ul>
<li><a href="../sections.html">&lt;Directory&gt;、&lt;Location&gt;、&lt;Files&gt;配置段是如何工作的</a>中包含了当接受一个请求时，这些不同的配置段是如何组合工作的相关解释。</li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="LogLevel" id="LogLevel">LogLevel</a> <a name="loglevel" id="loglevel">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>控制错误日志的详细程度</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>LogLevel <var>level</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>LogLevel warn</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">LogLevel</code>用于调整记录在错误日志中的信息的详细程度。(参见<code class="directive"><a href="#errorlog">ErrorLog</a></code>指令)。可以选择下列<var>level</var>，依照重要性降序排列：</p>

    <table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="bordered">
<tr><th><strong>Level</strong> </th><th><strong>描述</strong> </th><th><strong>例子</strong> </th></tr>
<tr><td><code>emerg</code> </td><td>紧急(系统无法使用)</td><td>"Child cannot open lock file. Exiting"</td></tr>
<tr><td><code>alert</code> </td><td>必须立即采取措施</td><td>"getpwuid: couldn't determine user name from uid"</td></tr>
<tr><td><code>crit</code> </td><td>致命情况</td><td>"socket: Failed to get a socket, exiting child"</td></tr>
<tr><td><code>error</code> </td><td>错误情况</td><td>"Premature end of script headers"</td></tr>
<tr><td><code>warn</code> </td><td>警告情况</td><td>"child process 1234 did not exit, sending another SIGHUP"</td></tr>
<tr><td><code>notice</code> </td><td>一般重要情况</td><td>"httpd: caught SIGBUS, attempting to dump core in
        ..."</td></tr>
<tr><td><code>info</code> </td><td>普通信息</td><td>"Server seems busy, (you may need to increase
        StartServers, or Min/MaxSpareServers)..."</td></tr>
<tr><td><code>debug</code> </td><td>调试信息</td><td>"Opening config file ..."</td></tr>
</table>

    <p>当指定了某个级别时，所有级别高于它的信息也会被同时记录。比如，指定 <code>LogLevel info</code> ，则所有<code>notice</code>和<code>warn</code>级别的信息也会被记录。</p>

    <p>建议至少使用<code>crit</code>级别。</p>

    <p>示例如下：</p>

    <div class="example"><p><code>
      LogLevel notice
    </code></p></div>

    <div class="note"><h3>注意</h3>
      <p>当错误日志是一个单独分开的正式文件的时候，<code>notice</code>级别的消息总是会被记录下来，而不能被屏蔽。但是，当使用<code>syslog</code>来记录时就没有这个问题。</p>
    </div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="MaxKeepAliveRequests" id="MaxKeepAliveRequests">MaxKeepAliveRequests</a> <a name="maxkeepaliverequests" id="maxkeepaliverequests">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>一个持久链接中允许的最大请求数量</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>MaxKeepAliveRequests <var>number</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>MaxKeepAliveRequests 100</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">MaxKeepAliveRequests</code>指令限制了当启用<code class="directive"><a href="#keepalive">KeepAlive</a></code>时，每个连接允许的请求数量。如果将此值设为"<code>0</code>"，将不限制请求的数目。我们建议最好将此值设为一个比较大的值，以确保最优的服务器性能。</p>

    <p>例如：</p>

    <div class="example"><p><code>
      MaxKeepAliveRequests 500
    </code></p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="NameVirtualHost" id="NameVirtualHost">NameVirtualHost</a> <a name="namevirtualhost" id="namevirtualhost">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>为一个基于域名的虚拟主机指定一个IP地址(和端口)</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>NameVirtualHost <var>addr</var>[:<var>port</var>]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>如果您要配置<a href="../vhosts/index.html">基于域名的虚拟主机</a>，<code class="directive">NameVirtualHost</code>指令就是您必须的指令之一。</p>

    <p>尽管<var>addr</var>参数可以使用主机名，但建议您还是使用IP地址。比如：</p>

    <div class="example"><p><code>
      NameVirtualHost 111.22.33.44
    </code></p></div>

    <p>使用<code class="directive">NameVirtualHost</code>指令，您可以指定一个基于域名的虚拟主机将使用哪个IP地址来接受请求。在一个防火墙或是其它代理接受了请求并把它转到服务器所在的另外一个IP地址上的情况下，您必须指定伺服请求的机器物理界面上的IP地址。如果您对于多个地址使用了多个基于域名的虚拟主机，您应该为每个地址使用这个指令。</p>

    <div class="note"><h3>注意</h3>
      <p>"主服务器"和任何其它"<code>_default_</code>"服务器都<strong>不会</strong>伺服发送到<code class="directive">NameVirtualHost</code> IP地址的请求。(除非您指定了<code class="directive">NameVirtualHost</code>，但没有为这个地址指定任何<code class="directive">VirtualHost</code>)。</p>
    </div>

    <p>另外，您还可以为您使用的基于域名的虚拟主机指定一个端口号。比如：</p>

    <div class="example"><p><code>
      NameVirtualHost 111.22.33.44:8080
    </code></p></div>

    <p>IPv6地址必须封装在一对方括号内，如下例所示：</p>

    <div class="example"><p><code>
      NameVirtualHost [2001:db8::a00:20ff:fea7:ccea]:8080
    </code></p></div>

    <p>为了接受所有界面的请求，您可以使用"<code>*</code>"：</p>

    <div class="example"><p><code>
      NameVirtualHost *
    </code></p></div>

    <div class="note"><h3><code class="directive">&lt;VirtualHost&gt;</code>指令的参数</h3>
      <p>请注意，<code class="directive">&lt;VirtualHost&gt;</code>指令的参数必须与<code class="directive">NameVirtualHost</code>指令的参数完全匹配。</p>

      <div class="example"><p><code>
        NameVirtualHost 1.2.3.4<br />
        &lt;VirtualHost 1.2.3.4&gt;<br />
        # ...<br />
        &lt;/VirtualHost&gt;<br />
      </code></p></div>
    </div>

<h3>参见</h3>
<ul>
<li><a href="../vhosts/index.html">虚拟主机文档</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="Options" id="Options">Options</a> <a name="options" id="options">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>配置在特定目录中可以使用哪些特性</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>Options [+|-]<var>option</var> [[+|-]<var>option</var>] ...</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>Options All</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>Options</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">Options</code>指令控制了在特定目录中将使用哪些服务器特性。</p>

    <p><var>option</var>可以为<code>None</code> ，在这种情况下，将不启用任何额外特性。或设置为以下选项中的一个或多个：</p>

    <dl>
      <dt><code>All</code></dt>

      <dd>除<code>MultiViews</code>之外的所有特性。这是默认设置。</dd>

      <dt><code>ExecCGI</code></dt>

      <dd>允许使用<code class="module"><a href="../mod/mod_cgi.html">mod_cgi</a></code>执行CGI脚本。</dd>

      <dt><code>FollowSymLinks</code></dt>

      <dd>服务器允许在此目录中使用符号连接。
      <div class="note">
      <p>注意：即使服务器会使用符号连接，但它<em>不会</em>改变用于匹配<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>段的路径名。</p>
      <p>注意：如果此配置位于<code class="directive"><a href="#location">&lt;Location&gt;</a></code>配置段中，则此设置会被<strong>忽略</strong>。</p>
      </div></dd>

      <dt><code>Includes</code></dt>

      <dd>允许使用<code class="module"><a href="../mod/mod_include.html">mod_include</a></code>提供的服务器端包含。</dd>

      <dt><code>IncludesNOEXEC</code></dt>

      <dd>允许服务器端包含，但禁用"<code>#exec cmd</code>"和"<code>#exec cgi</code>"。但仍可以从<code class="directive"><a href="../mod/mod_alias.html#scriptalias">ScriptAlias</a></code>目录使用"<code>#include virtual</code>"虚拟CGI脚本。</dd>

      <dt><code>Indexes</code></dt>

      <dd>如果一个映射到目录的URL被请求，而此目录中又没有<code class="directive"><a href="../mod/mod_dir.html#directoryindex">DirectoryIndex</a></code>(例如：<code>index.html</code>)，那么服务器会返回由<code class="module"><a href="../mod/mod_autoindex.html">mod_autoindex</a></code>生成的一个格式化后的目录列表。</dd>

      <dt><code>MultiViews</code></dt>

      <dd>允许使用<code class="module"><a href="../mod/mod_negotiation.html">mod_negotiation</a></code>提供<a href="../content-negotiation.html">内容协商</a>的"多重视图"(MultiViews)。</dd>

      <dt><code>SymLinksIfOwnerMatch</code></dt>

      <dd>服务器仅在符号连接与其目的目录或文件的拥有者具有相同的uid时才使用它。
      <div class="note"><h3>注意</h3>如果此配置出现在<code class="directive"><a href="#location">&lt;Location&gt;</a></code>配置段中，此选项将被忽略。</div>
      </dd>
    </dl>

    <p>一般来说，如果一个目录被多次设置了<code class="directive">Options</code> ，则最特殊的一个会被完全接受(其它的被忽略)，而各个可选项的设定彼此并不融合(参见<a href="../sections.html#mergin">配置段的合并</a>)。然而，如果<em>所有</em>作用于<code class="directive">Options</code>指令的可选项前都加有"<code>+</code>"或"<code>-</code>"符号，此可选项将被合并。所有前面加有"<code>+</code>"号的可选项将强制覆盖当前的可选项设置，而所有前面有"<code>-</code>"号的可选项将强制从当前可选项设置中去除。</p>

    <p>比如，没有任何"<code>+</code>"或"<code>-</code>"符号：</p>

    <div class="example"><p><code>
      &lt;Directory /web/docs&gt;<br />
      <span class="indent">
        Options Indexes FollowSymLinks<br />
      </span>
      &lt;/Directory&gt;<br />
      <br />
      &lt;Directory /web/docs/spec&gt;<br />
      <span class="indent">
        Options Includes<br />
      </span>
      &lt;/Directory&gt;
    </code></p></div>

    <p>那么只有将<code>Includes</code>设置到<code>/web/docs/spec</code>目录上。然而如果第二个<code class="directive">Options</code>指令使用了"<code>+</code>"和"<code>-</code>"符号：</p>

    <div class="example"><p><code>
      &lt;Directory /web/docs&gt;<br />
      <span class="indent">
        Options Indexes FollowSymLinks<br />
      </span>
      &lt;/Directory&gt;<br />
      <br />
      &lt;Directory /web/docs/spec&gt;<br />
      <span class="indent">
        Options +Includes -Indexes<br />
      </span>
      &lt;/Directory&gt;
    </code></p></div>

    <p>那么就会有<code>FollowSymLinks</code>和<code>Includes</code>设置到<code>/web/docs/spec</code>目录上。</p>

    <div class="note"><h3>注意</h3>
      <p>使用 <code>-IncludesNOEXEC</code> 或 <code>-Includes</code> 时，不论前面如何设置，都会完全禁用服务器端包含。</p>
    </div>

    <p>没有其它设置时，默认设置为 <code>All</code> 。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="Require" id="Require">Require</a> <a name="require" id="require">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>指定哪些认证用户允许访问该资源</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>Require <var>entity-name</var> [<var>entity-name</var>] ...</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>这个指令指定哪些认证用户允许访问该资源。这些限制由授权支持模块实现。语法如下：</p>

    <dl>
      <dt><code>Require user <var>userid</var> [<var>userid</var>] ...</code></dt>
      <dd>只有指定的用户可以访问此目录。</dd>

      <dt><code>Require group <var>group-name</var> [<var>group-name</var>] ...</code></dt>
      <dd>只有隶属于指定组的用户可以访问此目录。</dd>

      <dt><code>Require valid-user</code></dt>
      <dd>所有有效用户都可以访问此目录。</dd>
    </dl>

    <p>提供<code>Require</code>指令的授权支持模块有：<code class="module"><a href="../mod/mod_authz_user.html">mod_authz_user</a></code>, <code class="module"><a href="../mod/mod_authz_groupfile.html">mod_authz_groupfile</a></code>, <code class="module"><a href="../mod/mod_authnz_ldap.html">mod_authnz_ldap</a></code>, <code class="module"><a href="../mod/mod_authz_dbm.html">mod_authz_dbm</a></code>, <code class="module"><a href="../mod/mod_authz_owner.html">mod_authz_owner</a></code> 。</p>

    <p><code class="directive">Require</code>必须伴随<code class="directive"><a href="#authname">AuthName</a></code>和<code class="directive"><a href="#authtype">AuthType</a></code>指令，以及诸如<code class="directive"><a href="../mod/mod_authn_file.html#authuserfile">AuthUserFile</a></code>和<code class="directive"><a href="../mod/mod_authz_groupfile.html#authgroupfile">AuthGroupFile</a></code>指令(用以定义用户和用户组)以确保其能够正确工作。例如：</p>

    <div class="example"><p><code>
       AuthType Basic<br />
       AuthName "Restricted Resource"<br />
       AuthUserFile /web/users<br />
       AuthGroupFile /web/groups<br />
       Require group admin
    </code></p></div>

    <p>使用这种方法提供的访问控制对<strong>所有</strong>方法都有效。<strong>这是一般情况下期望达到的效果</strong>。如果您仅希望对某个特定的方法加以限制，而不涉及其它方法时，您可以将<code class="directive">Require</code>语句放入<code class="directive"><a href="#limit">&lt;Limit&gt;</a></code>配置段中。</p>
 
    <p>如果<code class="directive">Require</code>与<code class="directive"><a href="../mod/mod_authz_host.html#allow">Allow</a></code>或<code class="directive"><a href="../mod/mod_authz_host.html#deny">Deny</a></code>指令同时使用，那么这些指令之间的相互作用由<code class="directive"><a href="#satisfy">Satisfy</a></code>指令控制。</p>

    <div class="note"><h3>在子目录中删除访问控制</h3>
    <p>下面的例子展示了如何使用<code class="directive"><a href="#satisfy">Satisfy</a></code>指令在一个受保护的目录下的子目录中取消访问控制。使用这种方法必须十分小心，因为它取消了<code class="module"><a href="../mod/mod_authz_host.html">mod_authz_host</a></code>实现的任何访问控制。</p>
    <div class="example"><p><code>
      &lt;Directory /path/to/protected/&gt;<br />
        <span class="indent">
        Require user david<br />
        </span>
      &lt;/Directory&gt;<br />
      &lt;Directory /path/to/protected/unprotected&gt;<br />
        <span class="indent">
        # 该目录下的所有认证和访问控制都被取消了<br />
        Satisfy Any<br />
        Allow from all<br />
        </span>
      &lt;/Directory&gt;<br />
    </code></p></div>
    </div>

<h3>参见</h3>
<ul>
<li><a href="../howto/auth.html">认证、授权、访问控制</a></li>
<li><code class="directive"><a href="#satisfy">Satisfy</a></code></li>
<li><code class="module"><a href="../mod/mod_authz_host.html">mod_authz_host</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="RLimitCPU" id="RLimitCPU">RLimitCPU</a> <a name="rlimitcpu" id="rlimitcpu">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>限制Apache子进程派生的进程占用CPU的最大秒数</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>RLimitCPU <var>seconds</var>|max [<var>seconds</var>|max]</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>未定义，使用操作系统默认值</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>使用一个或两个参数。第一个参数设置了所有进程的软资源限制，第二个参数设置了最大资源限制。两个参数均可设置为一个数值或是"<code>max</code>"以表示设置为操作系统允许的最大值。增大此资源限制最大值需要以<code>root</code>运行服务器或是在初始化启动语句中进行设置。</p>

    <p>这个限制将作用于Apache子进程服务的请求所衍生出的进程，而不是Apache子进程本身。这个范围包括CGI脚本和SSI执行命令，但不包括所有从Apache父进程衍生出的进程。比如管道日志。</p>

    <p>CPU资源限制表示为每进程占用的秒数。</p>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#rlimitmem">RLimitMEM</a></code></li>
<li><code class="directive"><a href="#rlimitnproc">RLimitNPROC</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="RLimitMEM" id="RLimitMEM">RLimitMEM</a> <a name="rlimitmem" id="rlimitmem">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>限制由Apache子进程派生的进程占用的最大内存字节数</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>RLimitMEM <var>bytes</var>|max [<var>bytes</var>|max]</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>未定义，使用操作系统默认值</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>使用一个或两个参数。第一个参数设置了所有进程的软资源限制，第二个参数设置了最大资源限制。两个参数均可设置为一个数值或是"<code>max</code>"以表示设置为操作系统允许的最大值。增大此资源限制最大值需要以<code>root</code>运行服务器或是在初始化启动语句中进行设置。</p>

    <p>这个限制将作用于Apache子进程服务的请求所衍生出的进程，而不是Apache子进程本身。这个范围包括CGI脚本和SSI执行命令，但不包括所有从Apache父进程衍生出的进程。比如管道日志。</p>

    <p>内存资源限制表示为每进程占用的字节数。</p>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#rlimitcpu">RLimitCPU</a></code></li>
<li><code class="directive"><a href="#rlimitnproc">RLimitNPROC</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="RLimitNPROC" id="RLimitNPROC">RLimitNPROC</a> <a name="rlimitnproc" id="rlimitnproc">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>限制由Apache子进程派生的进程所派生的进程数目</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>RLimitNPROC <var>number</var>|max [<var>number</var>|max]</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>未定义，使用操作系统默认值</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>使用一个或两个参数。第一个参数设置了所有进程的软资源限制，第二个参数设置了最大资源限制。两个参数均可设置为一个数值或是"<code>max</code>"以表示设置为操作系统允许的最大值。增大此资源限制最大值需要以<code>root</code>运行服务器或是在初始化启动语句中进行设置。</p>

    <p>这个限制将作用于Apache子进程服务的请求所衍生出的进程，而不是Apache子进程本身。这个范围包括CGI脚本和SSI执行命令，但不包括所有从Apache父进程衍生出的进程。比如管道日志。</p>

    <p>进程限制控制了每个用户的进程数。</p>

    <div class="note"><h3>注意</h3>
      <p>如果CGI进程<strong>不是</strong>以web服务器的uid启动的，那么这个指令将限制服务器自己能够创建的进程数目。此种情况将在<code>error_log</code>中以"<strong><code>cannot fork</code></strong>"进行记录。</p>
    </div>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#rlimitmem">RLimitMEM</a></code></li>
<li><code class="directive"><a href="#rlimitcpu">RLimitCPU</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="Satisfy" id="Satisfy">Satisfy</a> <a name="satisfy" id="satisfy">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>主机级别的访问控制和用户认证之间的相互关系</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>Satisfy Any|All</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>Satisfy All</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>AuthConfig</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>2.0.51及以后版本中受<code class="directive"><a href="#limit">&lt;Limit&gt;</a></code>和<code class="directive"><a href="#limitexcept">&lt;LimitExcept&gt;</a></code>指令影响</td></tr>
</table>
    <p>同时使用<code class="directive"><a href="../mod/mod_authz_host.html#allow">Allow</a></code>和<code class="directive"><a href="#require">Require</a></code>时的访问策略。参数可以设置为 <code>All</code> 或 <code>Any</code> 。这个指令仅在某个特定区域的访问控制同时被用户名/密码<em>和</em>客户端主机地址进行限定的时候起作用。默认行为(<code>All</code>)采取客户端首先通过地址访问限制<em>并且</em>输入有效的用户名和密码的方式。使用可选项 <code>Any</code> 将使客户端在通过主机限制或是输入一个有效的用户名和密码两种方式之一得到访问权限。这样，就可以通过密码来限制一个区域的访问，但允许某些特定地址的客户端访问时不需要输入密码。</p>

    <p>比如，如果您想让您局域网内的用户访问您的web网站时不受限制，但局域网外的用户需提供密码才能进行访问，您可以采取类似如下的配置：</p>

    <div class="example"><p><code>
      Require valid-user<br />
      Allow from 192.168.1<br />
      Satisfy Any
    </code></p></div>

    <p>从2.0.51版本开始，<code class="directive">Satisfy</code>指令可以被限定于由<code class="directive"><a href="#limit">&lt;Limit&gt;</a></code>和<code class="directive"><a href="#limitexcept">&lt;LimitExcept&gt;</a></code>配置段指定的特定的方法。</p>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="../mod/mod_authz_host.html#allow">Allow</a></code></li>
<li><code class="directive"><a href="#require">Require</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ScriptInterpreterSource" id="ScriptInterpreterSource">ScriptInterpreterSource</a> <a name="scriptinterpretersource" id="scriptinterpretersource">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>定位CGI脚本解释器</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ScriptInterpreterSource Registry|Registry-Strict|Script</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ScriptInterpreterSource Script</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅用于Win32；<code>Registry-Strict</code>选项仅在 Apache 2.0 及以后的版本中可用</td></tr>
</table>
    <p>这个指令控制Apache如何找到运行CGI脚本的解释器。默认为<code>Script</code> ，使用在脚本中以"<code>#!</code>"行指定的解释器。在Win32上这一行通常看上去像：</p>

    <div class="example"><p><code>
      #!C:/Perl/bin/perl.exe
    </code></p></div>

    <p>或者，如果<code>perl</code>的位置已经在<code>PATH</code>中指定，则可以简单的写成：</p>

    <div class="example"><p><code>
      #!perl
    </code></p></div>

    <p>设置为 <code>ScriptInterpreterSource Registry</code> 将使用脚本文件扩展名(比如<code>.pl</code>)作为搜索项对Windows注册表项<code>HKEY_CLASSES_ROOT</code>进行搜索。 这个命令由注册表子键<code>Shell\ExecCGI\Command</code>或<code>Shell\Open\Command</code>定义(如果前者不存在)。如果无法找到该注册表项，Apache将采用默认值：<code>Script</code> 。</p>

    <div class="warning"><h3>安全</h3>
    <p>将 <code>ScriptInterpreterSource Registry</code> 和使用了<code class="directive"><a href="../mod/mod_alias.html#scriptalias">ScriptAlias</a></code>的目录一起使用时需要非常小心，因为Apache会执行这个目录下的<strong>所有</strong>文件。<code>Registry</code>设置可能会导致对不可执行文件的不期望的程序调用。例如，在大多数Windows上默认打开<code>.htm</code>文件的程序是IE，所以任何一个对脚本目录中<code>.htm</code>文件的请求将会在服务器后台打开一个IE。这是一个让你的服务器在数分钟内崩溃的好办法。</p>
    </div>

    <p><code>Registry-Strict</code>选项和<code>Registry</code>差不多，但是只使用<code>Shell\ExecCGI\Command</code>子键。<code>ExecCGI</code>键不是一个普通的键。它必须在注册表中手动配置，从而可以防止意外的程序调用。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ServerAdmin" id="ServerAdmin">ServerAdmin</a> <a name="serveradmin" id="serveradmin">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>服务器返回给客户端的错误信息中包含的管理员邮件地址</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ServerAdmin <var>email-address</var>|<var>URL</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">ServerAdmin</code>设置了在所有返回给客户端的错误信息中包含的管理员邮件地址。如果<code>httpd</code>不能将提供的参数识别为<var>URL</var>，它就会假定它是一个<var>email-address</var> ，并在超连接中用在<code>mailto:</code>后面。推荐使用一个Email地址，因为许多CGI脚本是这样认为的。如果你确实想使用URL，一定要保证指向一个你能够控制的服务器，否则用户将无法确保一定可以和你取得联系。</p>

    <p>为这个目的专门设置一个邮箱是值得的，比如：</p>

    <div class="example"><p><code>
      ServerAdmin www-admin@foo.example.com
    </code></p></div>
    <p>因为用户一般不会注意到他们在讨论服务器的问题！</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ServerAlias" id="ServerAlias">ServerAlias</a> <a name="serveralias" id="serveralias">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>匹配一个基于域名的虚拟主机的别名</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ServerAlias <var>hostname</var> [<var>hostname</var>] ...</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">ServerAlias</code>指令设定主机的别名，用于<a href="../vhosts/name-based.html">基于域名的虚拟主机</a>。</p>

    <div class="example"><p><code>
      &lt;VirtualHost *&gt;<br />
      ServerName server.domain.com<br />
      ServerAlias server server2.domain.com server2<br />
      # ...<br />
      &lt;/VirtualHost&gt;
    </code></p></div>

<h3>参见</h3>
<ul>
<li><a href="../vhosts/index.html">Apache虚拟主机文档</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ServerName" id="ServerName">ServerName</a> <a name="servername" id="servername">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>服务器用于辨识自己的主机名和端口号</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ServerName [<var>scheme</var>://]<var>fully-qualified-domain-name</var>[:<var>port</var>]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>在2.0版中，这个指令代替了1.3版的<code class="directive">Port</code>指令的功能；<var>scheme</var>仅在2.2.3及之后的版本中可用。</td></tr>
</table>
    <p><code class="directive">ServerName</code>指令设置了服务器用于辨识自己的主机名和端口号。这主要用于创建重定向URL。比如，一个放置web服务器的主机名为<code>simple.example.com</code> ，但同时有一个DNS别名<code>www.example.com</code> 。而您希望web服务器更显著一点，您可以使用如下的指令：</p>

    <div class="example"><p><code>
      ServerName www.example.com:80
    </code></p></div>

    <p>当没有指定<code class="directive">ServerName</code>时，服务器会尝试对IP地址进行反向查询来推断主机名。如果在<code class="directive">ServerName</code>中没有指定端口号，服务器会使用接受请求的那个端口。为了加强可靠性和可预测性，您应该使用<code class="directive">ServerName</code>显式的指定一个主机名和端口号。</p>

    <p>如果使用的是<a href="../vhosts/name-based.html">基于域名的虚拟主机</a>，在<code class="directive"><a href="#virtualhost">&lt;VirtualHost&gt;</a></code>段中的<code class="directive">ServerName</code>将是为了匹配这个虚拟主机，在"<code>Host:</code>"请求头中必须出现的主机名。</p>
    <p>可选的'scheme://'前缀仅在2.2.3以后的版本中可用，用于在代理之后或离线设备上也能正确的检测规范化的服务器URL。</p>
    <p>参见<code class="directive"><a href="#usecanonicalname">UseCanonicalName</a></code>和<code class="directive"><a href="#usecanonicalphysicalport">UseCanonicalPhysicalPort</a></code>指令以获得关于自引用URL(比如使用<code class="module"><a href="../mod/mod_dir.html">mod_dir</a></code>模块)是需要指定一个特定端口，还是使用客户端请求的端口号的更详细的信息。</p>

<h3>参见</h3>
<ul>
<li><a href="../misc/dns-caveats.html">关于DNS和Apache</a></li>
<li><a href="../vhosts/index.html">Apache虚拟主机文档</a></li>
<li><code class="directive"><a href="#usecanonicalname">UseCanonicalName</a></code></li>
<li><code class="directive"><a href="#usecanonicalphysicalport">UseCanonicalPhysicalPort</a></code></li>
<li><code class="directive"><a href="#namevirtualhost">NameVirtualHost</a></code></li>
<li><code class="directive"><a href="#serveralias">ServerAlias</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ServerPath" id="ServerPath">ServerPath</a> <a name="serverpath" id="serverpath">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>为兼容性不好的浏览器访问基于域名的虚拟主机保留的URL路径名</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ServerPath <var>URL-path</var></code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>virtual host</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">ServerPath</code>指令为主机设置了保守的(legacy)URL路径名，用于和<a href="../vhosts/index.html">基于域名的虚拟主机</a>配合使用。</p>

<h3>参见</h3>
<ul>
<li><a href="../vhosts/index.html">Apache虚拟主机文档</a></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ServerRoot" id="ServerRoot">ServerRoot</a> <a name="serverroot" id="serverroot">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>安装服务器的基础目录</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ServerRoot <var>directory-path</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ServerRoot /usr/local/apache</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">ServerRoot</code>指令设置了服务器所在的目录。一般来说它将包含<code>conf/</code>和<code>logs/</code>子目录。其它配置文件的相对路径即基于此目录 (比如<code class="directive"><a href="#include">Include</a></code>或<code class="directive"><a href="../mod/mod_so.html#loadmodule">LoadModule</a></code>)。</p>

    <div class="example"><h3>示例</h3><p><code>
      ServerRoot /home/httpd
    </code></p></div>


<h3>参见</h3>
<ul>
<li><a href="../invoking.html"><code>httpd</code>的 <code>-d</code> 选项</a></li>
<li><a href="../misc/security_tips.html#serverroot">安全提示</a>中关于如何正确设置<code class="directive">ServerRoot</code>权限的部分</li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ServerSignature" id="ServerSignature">ServerSignature</a> <a name="serversignature" id="serversignature">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>配置服务器生成页面的页脚</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ServerSignature On|Off|EMail</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ServerSignature Off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">ServerSignature</code>指令允许您配置服务器端生成文档的页脚(错误信息、<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>的ftp目录列表、<code class="module"><a href="../mod/mod_info.html">mod_info</a></code>的输出)。您启用这个页脚的原因主要在于处于一个代理服务器链中的时候，用户基本无法辨识出究竟是链中的哪个服务器真正产生了返回的错误信息。</p>

    <p>默认的 <code>Off</code> 设置没有错误行(这样便与Apache1.2及更旧版本兼容)。采用 <code>On</code> 会简单的增加一行关于服务器版本和正在伺服的虚拟主机的<code class="directive"><a href="#servername">ServerName</a></code> ，而 <code>EMail</code> 设置会如文档中说明的那样额外创建一个指向<code class="directive"><a href="#serveradmin">ServerAdmin</a></code>的"mailto:"部分。</p>

    <p>对于2.0.44以后的版本，显示的详细服务器版本号将由<code class="directive"><a href="#servertokens">ServerTokens</a></code>指令控制。</p>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#servertokens">ServerTokens</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="ServerTokens" id="ServerTokens">ServerTokens</a> <a name="servertokens" id="servertokens">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>配置"<code>Server:</code>"应答头</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>ServerTokens Major|Minor|Min[imal]|Prod[uctOnly]|OS|Full</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>ServerTokens Full</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>这个指令控制了服务器回应给客户端的"<code>Server:</code>"应答头是否包含关于服务器操作系统类型和编译进的模块描述信息。</p>

    <dl>
      <dt><code>ServerTokens Prod[uctOnly]</code></dt>

      <dd>服务器会发送(比如)： <code>Server: Apache</code></dd>

      <dt><code>ServerTokens Major</code></dt>

      <dd>服务器会发送(比如)： <code>Server: Apache/2</code></dd>

      <dt><code>ServerTokens Minor</code></dt>

      <dd>服务器会发送(比如)： <code>Server: Apache/2.0</code></dd>

      <dt><code>ServerTokens Min[imal]</code></dt>

      <dd>服务器会发送(比如)： <code>Server: Apache/2.0.41</code></dd>

      <dt><code>ServerTokens OS</code></dt>

      <dd>服务器会发送(比如)： <code>Server: Apache/2.0.41 (Unix)</code></dd>

      <dt><code>ServerTokens Full</code> (或未指定)</dt>

      <dd>服务器会发送(比如)： <code>Server: Apache/2.0.41 (Unix) PHP/4.2.2 MyMod/1.2</code></dd>
    </dl>

    <p>此设置将作用于整个服务器，而且不能用在虚拟主机的配置段中。</p>

    <p>2.0.44版本以后，这个指令还控制着<code class="directive"><a href="#serversignature">ServerSignature</a></code>指令的显示内容。</p>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#serversignature">ServerSignature</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SetHandler" id="SetHandler">SetHandler</a> <a name="sethandler" id="sethandler">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>强制所有匹配的文件被一个指定的处理器处理</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SetHandler <var>handler-name</var>|None</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>在Apache2.0中移入核心</td></tr>
</table>
    <p>当这个指令放入<code>.htaccess</code>或<code class="directive"><a href="#directory">&lt;Directory&gt;</a></code>或<code class="directive"><a href="#location">&lt;Location&gt;</a></code>配置段中时，这个指令将强制所有匹配的文件通过<var>handler-name</var>指定的<a href="../handler.html">处理器</a>处理。比如：如果想不管某个目录中的文件具有什么扩展名，都将它作为图像映射规则文件来解析，您可以将下例放入那个目录的<code>.htaccess</code>中：</p>

    <div class="example"><p><code>
      SetHandler imap-file
    </code></p></div>

    <p>再来一个例子：如果您想当<code>http://servername/status</code>被请求时，服务器显示一个状态报告，您可以将下面的语句放入<code>httpd.conf</code>里面：</p>

    <div class="example"><p><code>
      &lt;Location /status&gt;<br />
      <span class="indent">
        SetHandler server-status<br />
      </span>
      &lt;/Location&gt;
    </code></p></div>

    <p>你可以通过使用 <code>None</code> 来改写一个早先定义的<code class="directive">SetHandler</code>指令。</p>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="../mod/mod_mime.html#addhandler">AddHandler</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SetInputFilter" id="SetInputFilter">SetInputFilter</a> <a name="setinputfilter" id="setinputfilter">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>设置处理客户端请求和POST输入时使用的过滤器</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SetInputFilter <var>filter</var>[;<var>filter</var>...]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">SetInputFilter</code>指令为服务器接受并处理客户端请求和POST输入设置了过滤器。这是在其它地方(包括<code class="directive"><a href="../mod/mod_mime.html#addinputfilter">AddInputFilter</a></code>指令)设置的过滤器以外附加的过滤器。</p>

    <p>如果设置了多于一个过滤器，它们必须按照处理内容的顺序用分号(;)分隔。</p>

<h3>参见</h3>
<ul>
<li><a href="../filter.html">过滤器</a>文档</li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="SetOutputFilter" id="SetOutputFilter">SetOutputFilter</a> <a name="setoutputfilter" id="setoutputfilter">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>设置用于处理服务器输出应答的过滤器</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>SetOutputFilter <var>filter</var>[;<var>filter</var>...]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">覆盖项</a></th><td>FileInfo</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">SetOutputFilter</code>指令设置了用于在服务器应答发送到客户端之前使用的过滤器。这是在其它地方(包括<code class="directive"><a href="../mod/mod_mime.html#addoutputfilter">AddOutputFilter</a></code>指令)设置的过滤器以外附加的过滤器。</p>

    <p>例如：下述配置将会把<code>/www/data/</code>目录下的所有文件作为SSI文件来处理。</p>

    <div class="example"><p><code>
      &lt;Directory /www/data/&gt;<br />
      <span class="indent">
        SetOutputFilter INCLUDES<br />
      </span>
      &lt;/Directory&gt;
    </code></p></div>

    <p>如果设置了多于一个过滤器，它们必须按照处理内容的顺序用分号(;)分隔。</p>

<h3>参见</h3>
<ul>
<li><a href="../filter.html">过滤器</a>文档</li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="TimeOut" id="TimeOut">TimeOut</a> <a name="timeout" id="timeout">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>服务器在断定请求失败前等待的秒数</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>TimeOut <var>seconds</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>TimeOut 300</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">TimeOut</code>指令用于设置Apache等待以下三种事件的时间长度：</p>

    <ol>
      <li>接受一个GET请求耗费的总时间。</li>
      <li>POST或PUT请求时，接受两个TCP包之间的时间。</li>
      <li>应答时TCP包传输中两个ACK包之间的时间。</li>
    </ol>

    <p>我们计划在发展里程中，逐步把它们分别变得更易配置。计时器在1.2版本之前的默认值为1200，而现在已经设置为300了，但对于绝大多数情况来说仍是足够的。没有把它默认值设的更小的原因在于代码里还有点问题：有时发送一个包之后，计时器没有复位。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="TraceEnable" id="TraceEnable">TraceEnable</a> <a name="traceenable" id="traceenable">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>确定如何处理<code>TRACE</code>请求</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>TraceEnable <var>[on|off|extended]</var></code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>TraceEnable on</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 1.3.34, 2.0.55 及以后的版本中可用</td></tr>
</table>
    <p>这个指令同时决定了核心和<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>模块如何处理<code>TRACE</code>请求。默认(<code>TraceEnable on</code>)允许处理RFC2616定义的禁止附带任何请求体的<code>TRACE</code>请求。<code>TraceEnable off</code> 则使核心和<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>模块向客户端返回一个"<code>405</code>"(禁止的方法)错误。</p>

    <p>最后，为了测试和诊断，可以设置"<code>TraceEnable extended</code>"以允许附带请求体。核心(原始服务器)将会将请求体大小限制为64k以下(如果使用了 <code>Transfer-Encoding: chunked</code> 头，可以再为HTTP头增加8k)。核心会同时限制应答头和应答体；代理服务器则没有对请求体加以64k的限制。</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="UseCanonicalName" id="UseCanonicalName">UseCanonicalName</a> <a name="usecanonicalname" id="usecanonicalname">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>配置服务器如何确定它自己的域名</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>UseCanonicalName On|Off|DNS</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>UseCanonicalName Off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p>在很多情况下，Apache必须构造一个<em>自引用</em>URL(即一个指回相同服务器的URL)。使用 <code>UseCanonicalName On</code> 会将<code class="directive"><a href="#servername">ServerName</a></code>这个域名用于所有自引用URL、<code>SERVER_NAME</code>、CGI中的<code>SERVER_PORT</code> 。</p>

    <p>设置为 <code>UseCanonicalName Off</code> 时，如果客户端提供了主机名和端口(否则将如上所述使用标准域名)，Apache将会使用这些信息来构建自引用URL。这些值与用于实现<a href="../vhosts/name-based.html">基于域名的虚拟主机</a>的值相同，并且对于同样的客户端可用。CGI变量<code>SERVER_NAME</code>和<code>SERVER_PORT</code>也会由客户端提供的值来构建。</p>

    <p>用这样的方式成功解决问题的例子如下：在一个局域网内，您想让连接主机的用户使用诸如<code>www</code>这样的短域名进行访问。您会注意到，如果用户键入了类似<code>http://www/splat</code>这样的短域名和目录的URL，并且<em>没有最后的斜线</em>，Apache会将他们重定向到<code>http://www.domain.com/splat/</code>。如果您在这个目录上启用了身份验证，这会导致用户必须进行两次验证：一次针对<code>www</code>而另外一次针对<code>www.domain.com</code>(参见<a href="http://httpd.apache.org/docs/misc/FAQ.html#prompted-twice">关于此主题的FAQ</a>获得更多信息)。但如果<code class="directive">UseCanonicalName</code>设为 <code>Off</code> ，Apache就会重定向到<code>http://www/splat/</code>。</p>

    <p>第三个可选项是 <code>UseCanonicalName DNS</code> ，用于为大量基于IP的虚拟主机支持那些古董级的不提供"<code>Host:</code>"头的浏览器使用。使用这个选项时，Apache将对客户端连入的服务器的IP地址进行反向DNS查询，以构建自引用URL。</p>

    <div class="warning"><h3>警告</h3>
    <p>如果CGI对<code>SERVER_NAME</code>的值作出了假定，它们会被此选项破坏。客户端对于给出它们想要的主机名这样的行动是完全不受限制的。但如果CGI仅使用<code>SERVER_NAME</code>来构建自引用的URL，它们会工作的很好。</p>
    </div>

<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#usecanonicalphysicalport">UseCanonicalPhysicalPort</a></code></li>
<li><code class="directive"><a href="#servername">ServerName</a></code></li>
<li><code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="UseCanonicalPhysicalPort" id="UseCanonicalPhysicalPort">UseCanonicalPhysicalPort</a> <a name="usecanonicalphysicalport" id="usecanonicalphysicalport">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>配置服务器如何确定自己的端口</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>UseCanonicalPhysicalPort On|Off</code></td></tr>
<tr><th><a href="directive-dict.html#Default">默认值</a></th><td><code>UseCanonicalPhysicalPort Off</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config, virtual host, directory</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">兼容性</a></th><td>仅在 Apache 2.2.0 及以后的版本中可用</td></tr>
</table>
    <p>在很多情况下，Apache必须构造一个<em>自引用</em>URL(即一个指回相同服务器的URL)。在 <code>UseCanonicalPhysicalPort On</code> 的时候，Apache将有可能在构造服务器的规范端口时为了符合<code class="directive"><a href="#usecanonicalname">UseCanonicalName</a></code>指令而使用实际的物理端口号(physical port)。在 <code>UseCanonicalPhysicalPort Off</code> 的时候，Apache将不会使用实际的物理端口号，而是依赖所有已经配置的信息来构造一个合法的端口号。</p>

    <div class="note"><h3>注意</h3>
    <p>决定使用物理端口号的次序如下：<br /><br />
     <code>UseCanonicalName On</code></p>
     <ul>
      <li><code>Servername</code>指定的端口号</li>
      <li>物理端口号</li>
      <li>默认端口号</li>
     </ul>
     <code>UseCanonicalName Off | DNS</code>
     <ul>
      <li>"<code>Host:</code>"请求头提供的端口号</li>
      <li>物理端口号</li>
      <li><code>Servername</code>指定的端口号</li>
      <li>默认端口号</li>
     </ul>
    
    <p>在 <code>UseCanonicalPhysicalPort Off</code> 的情况下，物理端口号将会从上述顺序中剔除。</p>
    </div>


<h3>参见</h3>
<ul>
<li><code class="directive"><a href="#usecanonicalname">UseCanonicalName</a></code></li>
<li><code class="directive"><a href="#servername">ServerName</a></code></li>
<li><code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code></li>
</ul>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="VirtualHost" id="VirtualHost">&lt;VirtualHost&gt;</a> <a name="virtualhost" id="virtualhost">指令</a></h2>
<table border="1" cellpadding="0" cellspacing="0" bordercolor="#AAAAAA" class="directive">
<tr><th><a href="directive-dict.html#Description">说明</a></th><td>包含仅作用于指定主机名或IP地址的指令</td></tr>
<tr><th><a href="directive-dict.html#Syntax">语法</a></th><td><code>&lt;VirtualHost <var>addr</var>[:<var>port</var>] [<var>addr</var>[:<var>port</var>]] ...&gt; ... &lt;/VirtualHost&gt;</code></td></tr>
<tr><th><a href="directive-dict.html#Context">作用域</a></th><td>server config</td></tr>
<tr><th><a href="directive-dict.html#Status">状态</a></th><td>核心(C)</td></tr>
<tr><th><a href="directive-dict.html#Module">模块</a></th><td>core</td></tr>
</table>
    <p><code class="directive">&lt;VirtualHost&gt;</code>和<code>&lt;/VirtualHost&gt;</code>用于封装一组仅作用于特定虚拟主机的指令。任何在虚拟主机配置中可以使用的指令也同样可以在这里使用。当服务器接受了一个特定虚拟主机的文档请求时，它会使用封装在<code class="directive">&lt;VirtualHost&gt;</code>配置段中的指令。<var>Addr</var>可以是：</p>

    <ul>
      <li>虚拟主机的IP地址</li>
      <li>虚拟主机IP地址对应的完整域名</li>
      <li>字符"<code>*</code>"，仅与"<code>NameVirtualHost *</code>"配合使用以匹配所有的IP地址</li>
      <li>字符串"<code>_default_</code>"，与基于IP的虚拟主机联用以捕获所有没有匹配的IP地址</li>
    </ul>

    <div class="example"><h3>示例</h3><p><code>
      &lt;VirtualHost 10.1.2.3&gt;<br />
      <span class="indent">
        ServerAdmin webmaster@host.foo.com<br />
        DocumentRoot /www/docs/host.foo.com<br />
        ServerName host.foo.com<br />
        ErrorLog logs/host.foo.com-error_log<br />
        TransferLog logs/host.foo.com-access_log<br />
      </span>
      &lt;/VirtualHost&gt;
    </code></p></div>


    <p>IPv6的地址必须放入方括号中指定，否则作为可选项的端口号将无法确定。一个IPv6的示例如下：</p>

    <div class="example"><p><code>
      &lt;VirtualHost [2001:db8::a00:20ff:fea7:ccea]&gt;<br />
      <span class="indent">
        ServerAdmin webmaster@host.example.com<br />
        DocumentRoot /www/docs/host.example.com<br />
        ServerName host.example.com<br />
        ErrorLog logs/host.example.com-error_log<br />
        TransferLog logs/host.example.com-access_log<br />
      </span>
      &lt;/VirtualHost&gt;
    </code></p></div>

    <p>每个虚拟主机必须对应不同的IP地址、端口号或是不同的主机名。在第一种情况下，服务器所在的物理机器必须配置为可以为多个IP地址接受IP包。(在机器没有多个网络硬件界面的情况下，如果您的操作系统支持，您可以使用 <code>ifconfig alias</code> 命令来达到这个目的)。</p>

    <div class="note"><h3>注意</h3>
    <p><code class="directive">&lt;VirtualHost&gt;</code>的使用并<strong>不影响</strong>Apache的监听地址。你需要使用<code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code>来确保Apache正在监听正确的地址。</p>
    </div>

    <p>当使用基于IP的虚拟主机时，特殊的名称"<code>_default_</code>"可以在没有匹配到其它列出的虚拟主机的情况下作为匹配任何IP地址的默认虚拟主机。在没有进行"<code>_default_</code>"虚拟主机的设定时，在没有IP与请求匹配的情况下，将使用"主服务器"(在所有虚拟主机配置段之外)的配置。但请注意：任何匹配<code class="directive"><a href="#namevirtualhost">NameVirtualHost</a></code>指令的IP地址既不会使用"主服务器"配置，也不会使用"<code>_default_</code>"虚拟主机的配置。参见<a href="../vhosts/name-based.html">基于域名的虚拟主机</a>文档。</p>

    <p>您可以指定一个"<code>:port</code>"来改变匹配的端口。如果没有指定，它将沿用主服务器中离它最近的那个<code class="directive"><a href="../mod/mpm_common.html#listen">Listen</a></code>指定的值。您也可以指定"<code>:*</code>"来匹配那个地址上的所有端口(当您使用"<code>_default_</code>"时，这是推荐采用的方法)。</p>

    <div class="warning"><h3>安全</h3>
    <p>参见<a href="../misc/security_tips.html">安全提示</a>文档以获得为什么当您存储日志文件的目录对于启动服务器以外的用户来说是可写的会危及服务器安全的详细资料。</p>
    </div>

<h3>参见</h3>
<ul>
<li><a href="../vhosts/index.html">Apache虚拟主机文档</a></li>
<li><a href="../misc/dns-caveats.html">关于DNS和Apache</a></li>
<li><a href="../bind.html">设置Apache使用的地址和端口</a></li>
<li><a href="../sections.html">&lt;Directory&gt;、&lt;Location&gt;、&lt;Files&gt;配置段是如何工作的</a>中包含了当接受一个请求时，这些不同的配置段是如何组合工作的相关解释。</li>
</ul>
</div>
</div>
<div id="footer">
<p class="apache">本文允许自由使用、分发、转载，但必须保留译者署名；详见：<a href="../translator_announcement.html#announcement">译者声明</a>。</p>
<p class="menu"><a href="../mod/index.html">模块索引</a> | <a href="../mod/directives.html">指令索引</a> | <a href="../faq/index.html">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">站点导航</a></p></div>
</body></html>
